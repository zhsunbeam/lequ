{"meta":{"title":"极乐空间","subtitle":"安静的来点代码","description":"","author":"Mars笑笑生","url":"https://zhsunbeam.github.io","root":"/"},"pages":[{"title":"关于极乐空间","date":"2021-08-10T16:00:00.000Z","updated":"2022-07-17T02:44:51.399Z","comments":true,"path":"about/index.html","permalink":"https://zhsunbeam.github.io/about/index.html","excerpt":"","text":"N 年软件开发/培训老兵，搞项目、技术分享，从前端到后端，从代码到架构，不一而足；常吐槽各类IT机构少则二万多则三四万的培训费，结果却只会CRUD; 练技能不玩虚的；如果您喜欢编程、并有意以此为职业，或许我们可以一起成长，无论线上线下，绝对超值。"},{"title":"分类","date":"2021-08-11T12:30:54.000Z","updated":"2021-08-11T12:50:03.657Z","comments":true,"path":"categories/index.html","permalink":"https://zhsunbeam.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-11T12:41:12.000Z","updated":"2021-08-11T14:31:22.690Z","comments":true,"path":"tags/index.html","permalink":"https://zhsunbeam.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 模块化编程","slug":"Java/Java模块化","date":"2022-07-17T03:44:51.934Z","updated":"2022-07-18T03:52:46.508Z","comments":true,"path":"2022/07/17/Java/Java模块化/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/Java%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"现在，Java每半年发布一个版本，知道为什么这么快吗？这主要得益于Java的模块化技术。 换作以前，时间得以【年】计算。 从本质上讲，模块化(modularization） 是指将系统分解成独立且相互连接的模块的行为。模抉（ module） 是包含代码的可识别部分，使用元数据来描述模块与其它模块之间的关系。在Java 模块系统之前， JDK 的运行时库由一个庞大的rt.jar 所组成，其大小超过60MB ，包含了Java 大部分运行时类： 即Java 平台的最终载体。为了获得一个灵活且符合未来发展方向的平台， JDK 团队着手对JDK 进行模块化。模块化可以将jar声明为模块，它将在其自己的隔离类加载器中运行，该类加载器以OSGI方式从其他类似的模块类加载器读取类文件。这将允许同一版本的Jar的多个版本共存。 毕竟Java太庞大，模块化过程持续了几年时间，最终随Java9发布. Java9模块化系统出现以前Java模块化的核心三原则: 组合使用package和访问修饰符(public,protected,private)可以实现类型封装 定义良好的接口, 也就是使用interface关键字公开公共接口 显式依赖，也就是使用import关键字 Java9之后模块化 JDK 由大约90个模抉组成，而不是一个整体库。与可由自己创建的应用程序模块不同的是，平台模块是JDK的一部分。从技术上讲，平台模块和应用模块之间没有任何技术区别。每个平台模块都构成了JDK 的一个定义良好的功能块，从日志记录到XML 支持。所有模块都显式地定义了与其他模块的依赖关系。 模块工作原理 什么是模块，它是如何定义的？模块拥有一个名称，并对相关的代码以及可能的其他资源进行分组，使用一个模块描述符进行描述。模块描述符保存在一个名为 module-info.java 的文件中, 为此我们先创建一个Project,然后在Project下创建两个module, 如图所示: 创建一个Project jfxdemo 在这个jfxdemo工程下创建二个javafx module, 以下是第一个模块demo1 第二个模块 demo2 创建完成后可以发现，每个module下都有一个模块描述文件 module-info.java 此处我们使用javafx是为了后续开发游戏做准备，同时Javafx库默认情况下不能直接在应用程序中使用，必须使用模块描述文件来导入 查看demo1模块的module-info.java文件 123456module com.example1.demo1 &#123; requires javafx.controls; requires javafx.fxml; opens com.example.demo1 to javafx.fxml; exports com.example1.demo1;&#125; module-info.java文件中的第一行表示，当前应用是一个模块，模块名为 com.example.demo1, 模块名称虽然随便写个字符串也可以，但最好以域名作为基础，也就是使用反向DNS符号来确保模块的唯一性，后面紧跟着项目名称，建议尽量使用自己的域名。模块都位于一个全局命名空间中，因此，模块名称必须唯一。 requires 表示一个依赖关系，此是表示当前应用程序需要使用到javafx.controls模块以及javafx.xml模块,如果将这两句代码删除，那么在需要引用这两个模块的类中将会提示错误, 如下图所示 : 注释了requires javafx.fxml; 在HelloApplication中将无法使用 exports的意思是来自com.example.demo1模块的单个包被导出到其它模块 opens表示com.example.demo1中的类型可用于深度反射 模块化开发 在demo2模块中需要使用demo1模块中的定义的类 demo1模块中的module-info.java配置如下: 123456module com.example.demo1 &#123; requires javafx.controls; requires javafx.fxml; opens com.example.demo1 to javafx.fxml; exports com.example.demo1;&#125; 在module demo2中的pom.xml文件中加入demo1的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在demo2中要使用demo1模块中的类，则需要在demo2 模块中修改module-info.java文件 12345678module com.example.demo2 &#123; requires javafx.controls; requires javafx.fxml; requires com.example.demo1; //引入名称为com.example.demo1的模块 opens com.example.demo2 to javafx.fxml; exports com.example.demo2;&#125; 在demo2模块中的HelloApplication中使用demo1模块中的类 123456789101112131415161718192021222324package com.example.demo2;import javafx.application.Application;import javafx.fxml.FXMLLoader;import javafx.scene.Scene;import javafx.stage.Stage;import java.io.IOException;import com.example.demo1.*; //此处引用demo1模块APIpublic class HelloApplication extends Application &#123; @Override public void start(Stage stage) throws IOException &#123; FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource(&quot;hello-view.fxml&quot;)); Scene scene = new Scene(fxmlLoader.load(), 320, 240); stage.setTitle(&quot;Hello!&quot;); stage.setScene(scene); stage.show(); &#125; public static void main(String[] args) &#123; launch(); &#125;&#125; 如果在demo1模块中新建两个包，demo2模块中需要引用则要在demo1模块的module-info.java 文件中加入exports demo2模块中的HelloApplication 1234567891011121314151617181920212223242526package com.example.demo2;import javafx.application.Application;import javafx.fxml.FXMLLoader;import javafx.scene.Scene;import javafx.stage.Stage;import java.io.IOException;import com.example.demo1.*;import com.example.demo1.service.*;import com.example.demo1.dao.*;public class HelloApplication extends Application &#123; @Override public void start(Stage stage) throws IOException &#123; FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource(&quot;hello-view.fxml&quot;)); Scene scene = new Scene(fxmlLoader.load(), 320, 240); stage.setTitle(&quot;Hello!&quot;); stage.setScene(scene); stage.show(); &#125; public static void main(String[] args) &#123; launch(); &#125;&#125; 上面的内容中使用了java11进行模块化开发的第一步，也就是手动编写自己的第一个模块，而不仅仅是查看JDK中现有的模块。有了这部分经验后，后续就可以创建更加复杂的模块","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程-猜数字","slug":"Java/玩游戏学编程","date":"2022-07-17T01:19:56.088Z","updated":"2021-11-30T06:07:33.303Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一些编程初学者的痛点在于认识的英语单词太少，不知道程序在运行过程中需要什么？通过开发游戏学习编程，是一个快速但又不会觉得枯燥的方法；在这篇简单的猜数字游戏中，来看看程序开发过程中逻辑是怎样形成的？为了达到期望的结果，需要做哪些工作? 猜数字游戏过程: 用户自己输入一个数字A和程序中产生的一个数字B进行比较，如果A大于B则提示太大了，否则提示太小了，直到输入的数字A与产生的数字B相等，游戏结束，程序还需要设置一个猜的次数，如果超过次数则没猜中则游戏失败，否则成功。 猜数字游戏一、问题 程序中需要哪些变量? 用户要怎样输入? 怎样产生随机数字 ? 怎样使用循环和判断 ? 怎样创建对象 ? 它是用来干嘛的 ? 二、解决问题 使用Scanner对象获取玩家的输入，当然还需要System.in 定义变量input用于存储用户输入的数字，定义number存储计算机生成的随机数 为了控制循环和判断的逻辑还需要两个控制变量 running 和 guessed 为了控制玩家输入的次数，需要定义count计数器变量计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package top.coolcode;import java.util.Scanner; public class GuessNumber &#123; public static void main( String[] args ) &#123; //玩家需要输入，且输入的会是一个数字 Scanner sc = new Scanner(System.in); //程序运行所需要的要素,我怎么会想到需要这个,你是怎样想到的? boolean running = true; //控制游戏是否继续 boolean guessed = true; //控制是否要猜数字 //计算机帮我们生成的数字 int number = 0; //游戏玩家输入的数字 int input = 0; //记录猜的次数 int count = 1; //游戏是否能一直玩，靠的是这个running while(running) &#123; if(count&gt;3) &#123; System.out.println(&quot;三次机会已用完，游戏失败. 您可以继续游戏；退出输入-1&quot;); guessed = true; &#125; //判断是否要猜数字 if(guessed==true) &#123; System.out.println(&quot;计算机已经随机产生一个数，范围是0~20&quot;); System.out.println(&quot;您可以猜猜看, 退出输入 -1&quot;); number = getRandom(20); guessed = false;//设置为false,如果后续没有设置为true，就不会产生新的随机数 &#125; //如果上面的if分支进入了，那么说明随机数字已经产生 //游戏玩家输入的数字 input = sc.nextInt(); //判断用户输入 //如果用户输入的是-1表示结束游戏, 更改判断变量running为false,循环将终止 if(input == -1) &#123; running = false; &#125; else if(input &gt; number) &#123; System.out.println(&quot;输入的数字太大了,退出输入 -1&quot;); &#125; else if(input &lt; number) &#123; System.out.println(&quot;输入的数字太小了,退出输入 -1&quot;); &#125; else if(input == number)&#123; System.out.println(&quot;您猜对了，您可以继续游戏；退出输入 -1&quot;); guessed = true; //如果玩家没有输入-1则此变量设置为true,会继续产生随机数字 &#125; count++;//次数累加 &#125; &#125; /** * 定义一个函数用于产生随机数 * @param max * @return */ public static int getRandom(int max) &#123; return (int)(Math.random()*max) + 1; &#125;&#125; 简单的猜数字游戏，重要的是知道如何定义和使用程序运行过程中需要的要素(变量)，以及程序的执行流程。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字UI","slug":"Java/玩游戏学编程(2)-猜数字UI界面","date":"2022-07-17T01:19:56.085Z","updated":"2021-11-30T07:39:55.359Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(2)-猜数字UI界面/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(2)-%E7%8C%9C%E6%95%B0%E5%AD%97UI%E7%95%8C%E9%9D%A2/","excerpt":"","text":"游戏需要图形界面，虽然互联网时代Java FX 使用频率很小, 但是作为开发者，技多不压身，况且UI源码中有很多经典设计，是各类设计模式聚集地，可以让开发者加深对OOP、设计模式的理解。 如果把UI界面运用到游戏中去，既学到知识又增加趣味，岂不乐哉。 数字游戏界面一、问题 怎样使用JavaFX创建一个UI界面? 怎样创建一个按钮并添加到UI界面中? 怎样监听一个按钮的事件? 怎样使用线程开启一个异步任务? 在异步任务中绘图并添加到UI窗口 二、解决问题 要编写一个JavaFX界面，需要创建一个类并继承javafx.application.Application类(Java8中可以直接使用，更高版本的Java引入了模块化，需要手动引入), 并重写start方法： 代码中的Stage参数可以认为是一个UI窗口，英文翻译成“舞台”, 调用它的show方法显示这个窗口 12345678910package top.coolcode;import javafx.application.Application;public class GuessApp extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //显示“舞台”窗口 primaryStage.show(); &#125;&#125; 窗口创建好之后需要创建一些内容放到这个窗口中，这个内容我们称为Scene , 英文翻译成场景 可以独立创建一个函数，这个函数用来创建窗口界面中的内容 界面元素包含一个按钮Button, 并为这个按钮添加了一个事件处理函数,代码中使用了箭头函数 设置对象的属性通常会使用set开头的函数 123456789101112131415161718192021222324252627282930313233343536373839package top.coolcode;import javafx.application.Application;public class GuessApp extends Application &#123; //垂直盒子布局容器 private VBox root; //游戏中的地砖面板 private Pane tilePane; //使用Executors创建线程 private ScheduledExecutorService servicePool = Executors.newSingleThreadScheduledExecutor(); //存储所有数字框 的集合 private List&lt;TileView&gt; tileSequence = new ArrayList&lt;&gt;(); @Override public void start(Stage primaryStage) throws Exception &#123; //createContent()函数将会独立出来用于创建内容 Scene scene = new Scene(this.createContent()); //显示“舞台”窗口 primaryStage.show(); &#125; private Parent createContent() &#123; //使用垂直盒子进行布局，界面元素将会垂直放置在这个盒子容器中 // root是定义在类上的属性 this.root = new VBox(); //设置布局容器大小(宽，高) root.setPrefSize(1024, 500); //创建按钮对象 Button button = new Button(&quot;开始&quot;); //为按钮添加一个事件处理函数startGame(),也就是说当按下按钮后，这个函数就会被调用 button.setOnAction(e-&gt;startGame()); //创建一个面板 Pane pane = new Pane(); //获取这个垂直盒子容器并将面板和按钮添加到容器中 root.getChildren().addAll(pane, button); //返回这个垂直盒子容器，返回的内容将会被添加到舞台Stage return root; &#125;&#125; 编写按钮事件处理函数 在函数中会调用随机产生数字方格的函数populateGrid()，并将此函数返回的内容添加到VBox根容器 此函数中有一个计划任务，实际上使用的是Java中的线程池，同时还使用到了Java8中的Stream编程 123456789private void startGame() &#123; this.tilePane = this.populateGrid(); this.root.getChildren().set(0, tilePane); //6秒后执行线程,计划任务 this.servicePool.schedule(()-&gt;&#123; tilePane.getChildren().stream().map(n-&gt;(TileView)n) .forEach(TileView::hide);//此处是遍历tilePane面板上的每一个元素，并调用它的hide方法 &#125;, 6, TimeUnit.SECONDS);&#125; populateGrid函数实现, 用于随机绘制数字框，并添加到UI界面中 此函数的逻辑稍显复杂，主要使用到了Point2D类，产生9个数字框，并需要判断每个数字框不重合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private Pane populateGrid() &#123; Pane pane = new Pane(); pane.setPrefSize(1024, 500); Random random = new Random(); List&lt;Point2D&gt; usedPoints = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= 9; i++) &#123; int randomX = random.nextInt(1024/80); int randomY = random.nextInt(500/80); Point2D p = new Point2D(randomX, randomY); //判断集合usedPoints中是否包含了p,如果包含了则重新创建，并添加到usedPoints集合中 while(usedPoints.contains(p)) &#123; randomX = random.nextInt(1024/80); randomY = random.nextInt(500/80); p = new Point2D(randomX,randomY); &#125; usedPoints.add(p); //此类是自建类，用于创建一个数字框 TileView tile = new TileView(Integer.toString(i)); tile.setTranslateX(randomX * 80); tile.setTranslateY(randomY * 80); tile.setOnMouseClicked(e-&gt;&#123; if(tileSequence.isEmpty()) &#123; System.out.println(&quot;游戏已结束&quot;); return; &#125; TileView correctTile = tileSequence.remove(0); if(tile == correctTile) &#123; tile.show(); &#125; else &#123; tileSequence.clear(); System.out.println(&quot;失败：游戏结束&quot;); &#125; &#125;); pane.getChildren().add(tile); tileSequence.add(tile); &#125; return pane;&#125;private static class TileView extends StackPane &#123; private Text text; TileView(String content) &#123; Rectangle border = new Rectangle(80,80,null); border.setStroke(Color.BLUEVIOLET); border.setStrokeWidth(4); border.setStrokeType(StrokeType.INSIDE); text = new Text(content); text.setFont(Font.font(64)); getChildren().addAll(border,text); setPickOnBounds(true); &#125; void hide() &#123; text.setVisible(false); &#125; void show() &#123; text.setVisible(true); &#125;&#125; 最后运行程序 123public static void main(String[] args) &#123; launch(args);&#125; 此程序融合了线程、集合、FX UI界面、事件、Stream， 亦有很多英文单词","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字-JavaFX-UI","slug":"Java/玩游戏学编程(2)-猜数字-JavaFX-UI","date":"2022-07-17T01:19:56.081Z","updated":"2021-12-02T03:46:08.436Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(2)-猜数字-JavaFX-UI/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(2)-%E7%8C%9C%E6%95%B0%E5%AD%97-JavaFX-UI/","excerpt":"","text":"在之前那篇中涉及到很多知识点，其中之一就是JavaFX，JavaFX 是一个开源的下一代客户端应用平台，适用于基于Java构建的桌面、移动端和嵌入式系统。JavaFX类似于Java Swing；学习桌面UI也不是一无是处，WEB前端不也是一样的需要UI，而且WEB前端已经把桌面软件犯过的错误再重犯一遍，然后再把桌面软件的解决方案和设计方案再重新发明一遍, 学习使用JavaFX对后续再学前端或许能更快进入状态。 一、窗口 前面那篇代码中用到这些API： Application， Stage， Pane， VBox， Button 直接运行下面这段代码会出现一个窗口, Stage可翻译成舞台，调用show()方法就是显示这个舞台(窗口) 123456789public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; primaryStage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 二、控件 Button 12345678910111213141516171819public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //按钮控件 Button button = new Button(&quot;ok&quot;); //布局面板 Pane pane = new Pane(); //设置布局面板宽和高 pane.setPrefSize(900,500); //将控件添加到布局面板 pane.getChildren().add(button); //创建一个场景，并将布局面板添加到其中 Scene scene = new Scene(pane); primaryStage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 使用垂直布局容器VBox 1234567891011121314151617181920public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //垂直盒子容器 VBox vBox = new VBox(); vBox.setPrefSize(900, 500); Button button = new Button(&quot;ok&quot;); Button button1 = new Button(&quot;cancel&quot;); Pane pane = new Pane(); pane.setPrefSize(100,50); //将控件添加到VBox vBox.getChildren().addAll(pane,button,button1); Scene scene = new Scene(vBox); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 画图: 使用Rectangle类 为按钮添加事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; Pane pane = new Pane(); pane.setPrefSize(800, 300); Tile tile = new Tile(&quot;1&quot;); pane.getChildren().add(tile); //创建按钮并为按钮设置事件监听 Button button = new Button(&quot;点击隐藏矩形框&quot;); //此处使用了lambda表达式 button.setOnAction(e-&gt;&#123; tile.hide();//隐藏tile &#125;); Scene scene = new Scene(pane); primaryStage.setScene(scene); primaryStage.show(); &#125; private static class Tile extends StackPane &#123; //定义一个文本 private Text text; Tile(String content) &#123; //定义一个矩形 Rectangle rect = new Rectangle(80,80,null); //颜色 rect.setStroke(Color.AQUAMARINE); //宽度 rect.setStrokeWidth(4); //类型 rect.setStrokeType(StrokeType.INSIDE); //创建文本 text = new Text(content); //设置文本字体 text.setFont(Font.font(64)); //添加到当前布局面板 this.getChildren().addAll(rect, text); setPickOnBounds(true); &#125; void hide() &#123; text.setVisible(false); &#125; void show() &#123; text.setVisible(true); &#125; &#125;&#125; 如果想生成多个矩形，而且位置随机，可以使用Random类， 此类用于产生随机数。 123456789101112131415161718private Parent populateGrid() &#123; Pane pane = new Pane(); for (int i = 0; i &lt; 10; i++) &#123; TileView tile = new TileView(Integer.toString(i)); Random random = new Random(); int randomX = random.nextInt(1024/80); int randomY = random.nextInt(500/80); tile.setTranslateX(randomX * 80); tile.setTranslateY(randomY * 80); tile.setOnMouseClicked(e-&gt;&#123; &#125;); pane.getChildren().add(tile); &#125; return pane;&#125; 使用下面的代码测试populateGrid方法 12345678910111213141516public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //===定义一个垂直盒子容器,populateGrid方法返回的Pane添加进去 VBox vBox = new VBox(); vBox.setPrefSize(1000, 500); //populateGrid函数将会返回一个Pane，Pane存放多个随机的矩形 vBox.getChildren().add( populateGrid()); Scene scene = new Scene(vBox); primaryStage.setScene(scene); primaryStage.show(); &#125;&#125; 以上代码简单介绍并使用JavaFX，对上一篇中的技术分解","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字-Stream","slug":"Java/玩游戏学编程(1)-猜数字-Stream","date":"2022-07-17T01:19:56.078Z","updated":"2022-07-17T03:39:58.166Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(1)-猜数字-Stream/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(1)-%E7%8C%9C%E6%95%B0%E5%AD%97-Stream/","excerpt":"","text":"在这一篇玩游戏学编程(1)-猜数字中出现了Stream相关技术， 先看看代码其中的一段代码： 12345678910this.tilePane = this.populateGrid(); this.root.getChildren().set(0, tilePane); //6秒后执行线程,计划任务this.servicePool.schedule( ()-&gt;&#123; tilePane.getChildren() .stream() .map(n-&gt;(Tile)n) .forEach(Tile::hide);&#125;, 6, TimeUnit.SECONDS); 代码中populateGrid()函数会返回一个Pane, 这个Pane中包含多个Tile, 每个Tile是一个矩形方框，其中还有一个数字, 那就意味着tilePane这个对象中有多个控件，我们可以通过循环或Stream遍历tilePane中的每一个控件; this.servicePool.schedule(lambda表达式）它可以传递一个Lambda表达式， 这里可以改成传统的自定义线程类对象，只不过现在可以用Lambda表达式的方式简写, 因为线程中的Runnable接口也只有一个抽象方法， 传统的代码写法如下: 12345678910111213//创建一个线程类，里边包含异步任务class ScheduleThread implements Runnable &#123; @Override public void run() &#123; ObservableList&lt;Node&gt; list = tilePane.getChildren(); for (int i = 0; i &lt; list.size(); i++) &#123; TileView tv = (TileView)list.get(i); tv.hide(); &#125; &#125;&#125;//创建一个异步任务，6秒后执行线程的run()方法this.servicePool.schedule(new ScheduleThread(), 6, TimeUnit.SECONDS); 遍历可以采用以下方式： 123456789//获取面板上的所有控件元素,返回的是一个集合ObservableList&lt;Node&gt; list = tilePane.getChildren();//遍历集合for (int i = 0; i &lt; list.size(); i++) &#123; //将集合中的每一个元素获取到，并强制转换成Tile对象 Tile tile = (TileView)list.get(i); //调用控件元素的hide方法 tile.hide();&#125; 以上这种方案很传统，代码繁杂，如果采用Lambda和Stream的方式，代码更简洁： 12345this.servicePool.schedule( ()-&gt;&#123; tilePane.getChildren().stream().map(n-&gt;(Tile)n) .forEach(Tile::hide); &#125;, 6, TimeUnit.SECONDS); 下面我们再来举个例子， 假如我们有一个ArrayList集合，其中存放了一些数据，那么遍历这种集合有两种方式 123456789101112131415List&lt;String&gt; fruitList = new ArrayList&lt;String&gt;();fruitList.add(&quot;苹果&quot;);fruitList.add(&quot;香蕉&quot;);fruitList.add(&quot;西瓜&quot;);//第一种遍历方式，每获取一个元素直接输出, 此种方式属于外部迭代for (int i = 0; i &lt; fruitList.size(); i++) &#123; String fruit = fruitList.get(i); System.out.println(fruit);&#125;//另一种方式，采用forEach,其实也是外部迭代，只是采用了Lambda表达式fruitList.forEach(item-&gt;&#123; System.out.println(item); &#125;);//如果仅仅是输出集合中的每一个元素，还可以使用更简单的写法fruitList.forEach(System.out::println); 我们可以使用Stream对这个集合进行过滤、筛选、切片、映射等操作, 这些操作称为对集合的中间操作，最后可以对Stream进行关闭操作称为终端操作， 比如我们使用java.util.stream.Stream接口中的map方法： 123fruitList.stream().map(item-&gt;&#123; return &quot;&amp;&quot;+item+&quot;&amp;&quot;; &#125;).collect(Collectors.toList()).forEach(System.out::println); 这段代码的意思是将迭代(遍历)集合中的每一个元素，迭代过程中每遇到一个元素会将其传递给Lambda表达式对应的方法，由方法处理完成之后返回，此处是将每个元素的前后添加一个&amp;符号，最后处理完所有元素后再将其转换为List集合 (collect 终端操作), 那么对于猜数字游戏中的如下代码意思是通过Stream接口的map方法，过程是将每一个元素转换成Tile对象，然后通过forEach迭代每一个元素并调用它的hide方法 12tilePane.getChildren().stream().map(n-&gt;(Tile)n) .forEach(Tile::hide); 初学者如果不理解Stream，只能通过大量的练习去熟练，如果能有函数式编程语言基础便更容易理解","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字-Lambda","slug":"Java/玩游戏学编程(1)-猜数字-Lambda和Stream","date":"2022-07-17T01:19:56.075Z","updated":"2022-07-17T02:43:23.633Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(1)-猜数字-Lambda和Stream/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(1)-%E7%8C%9C%E6%95%B0%E5%AD%97-Lambda%E5%92%8CStream/","excerpt":"","text":"概念在这一篇中出现了Lambda表达式和Stream玩游戏学编程(1)-猜数字， 它们在Java应用开发中现已成为常用的开发技术， Lambda表达式这玩艺在函数式编程语言如Ruby、JavaScript、Python中早已存在，Java只是把他们学了过来。你可以把Lambda表达式看作是一种匿名功能，也就是没有名称的方法,可以认为lambda它是一块代码，我们在使用时可以将这块代码传递出去，这样它后续可以执行一次或多次，如果你了解过匿名类，那么对Lambda的写法就不会感到太生涩。 Java中没有函数类型，如果要实现Lambda表达式就得将函数表达为对象，也就是实现了特定接口的类的实例，当然你先得对面向对象中的接口以及实现有一些经验。 简单的使用 任务：对一个数组进行排序，调用数组排序函数Arrays.sort(), 使用Lambda表达式自定义排序方式 默认排序方式 12345int[] a = &#123;3,21,4,99,32,87,9&#125;;Arrays.sort(a);for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+&quot;,&quot;);&#125; 输出排序结果：3,4,9,21,32,87,99, 如果我们需要控制比较结果，比如说从大到小排列，就必须自定义比较逻辑，这个比较逻辑需要实现一个接口Comparator, 这个接口称为函数式接口,而且这个接口只有一个抽象方法compare, 代码如下: 1234567891011private static class ComparatorNumber implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer m, Integer n) &#123; if(m&gt;n) &#123; return -1; &#125; return 0; &#125;&#125; 12345678Integer[] ary = &#123;3,21,4,99,32,87,9&#125;;//创建比较对象ComparatorNumber comparatorNumber = new ComparatorNumber();//第二个参数为自定义比较对象Arrays.sort(ary, comparatorNumber);for (int i = 0; i &lt; ary.length; i++) &#123; System.out.print(ary[i]+&quot;,&quot;);&#125; ComparatorNumber类的compare方法为比较方式的实现 使用Lambda表达式 上面的代码可以直接换成lambda表达式的方式，更简洁, 可以把它称为箭头函数，具体的语法如下: 1(参数1, 参数2) -&gt; &#123; 函数实现 &#125; 如果只有一个参数，语法还可以是下面这样: 1形参1 -&gt; &#123;函数实现&#125; 如果没有函数的实现只有一个返回代码，还可以用下面这种写法: 1形参1 -&gt; 返回的变量 比较函数的改造如下, 上面创建的比较类就不需要了 : 123456Arrays.sort(ary, (m,n)-&gt;&#123; if(m&gt;n) &#123; return -1; &#125; return 0;&#125;); 如果希望一个接口成为函数式接口，只需要这个接口中仅有一个抽象方法即可 如果对sort方法的第二个参数已有实现的代码，我们也可以直接拿过来使用, 下面的代码就是直接使用了Integer的比较方法compareTo,只是它的比较方式是从小到大，使用方法如下: 1Arrays.sort(ary,Integer::compareTo); Java 类库中有很多这样的接口，比如多线程中的Runnable接口, 那么对于玩游戏学编程(1)-猜数字这篇中的如下代码应该就能理解了，按钮的事件监听器对象本身也需要实现一个接口EventHandler, 并且此接口仅有一个抽象方法，此时可以使用Lambda表达式 123456789101112private static class ButtonLis implements EventHandler&lt;ActionEvent&gt; &#123; @Override public void handle(ActionEvent event) &#123; &#125;&#125;button.setOnAction(new ButtonLis());//忽略上面的代码，直接使用Lambda表达式Button button = new Button(&quot;开始&quot;);button.setOnAction(e-&gt;startGame());//开始按钮事件,startGame()是具体的实现","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"一个简单的前端机试题","slug":"JavaScript/JavaScript-Interview-1","date":"2022-07-17T01:19:56.056Z","updated":"2022-07-17T03:30:34.935Z","comments":true,"path":"2022/07/17/JavaScript/JavaScript-Interview-1/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/JavaScript-Interview-1/","excerpt":"","text":"一个简单的前端机试题，使用原生JavaScript或是JQuery又或是Vue，如果能快速搞定，用什么无所谓啦 效果图 还是有几点要求的 点击固定标签可以修改选中状态，选中方式为多选 自定义输入框可输入10个字以内的标签（限制中文） 点击确认会在标签后面新增一个自定义名称的标签，自定义标签数量超过5个之后，输入框和确认按钮置灰，不可点击 点击确认时，需要对当前自定义标签的名称进行去重，如果标签重复，需要在确认按钮后面用红色的文字提示“该标签已重复” 自定义的标签右上角会有个删除的按钮，点击删除按钮会删除该自定义标签","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://zhsunbeam.github.io/tags/HTML/"}]},{"title":"玩游戏学前端-贪吃蛇","slug":"JavaScript/snake","date":"2022-07-17T01:19:56.024Z","updated":"2022-07-17T03:22:52.563Z","comments":true,"path":"2022/07/17/JavaScript/snake/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake/","excerpt":"","text":"在游戏项目中学JavaScript WEB前端基础技术包含HTML5/CSS3/JavaScript, 当然除了基础技术前端还有框架如React,Vue等, 其中相对难一点的便是JavaScript和CSS3，CSS3学起来开心多了, JavaScript编程语言可没那么有趣，如果用它来实现游戏，我想趣味性要超越CSS3, 俗话说：兴趣是最好的老师；下面我们一步步来实现这个小游戏，在开发过程中去学习JavaScript语言和CSS3的关键技术要点。效果如下图所示 贪吃蛇 贪吃蛇游戏 1. HTML5和CSS3设计游戏界面 HTML页面组成，常用标签和meta 准确使用HTML标签div, 标签中的基本属性 为HTML标签添加样式 CSS3样式编写，标签选择器，ID选择器，类选择器 CSS3中的常用单位 px,rpx,em,rem,vh,vw,vmin,vmax CSS3边框和颜色 CSS3 Grid网格布局 2. HTML与Javascript ES5和ES6的基本认知 在HTML中添加Javascript脚本支持 Javascript语言基础: 变量、程序逻辑、函数、对象 Javascript的模块化 3. Javascript操作HTML元素 - DOM 使用Javascript选择HTML元素 Javascript动画 Javascript创建HTML元素 Javascript设置HTML元素样式 Javascript定义游戏核心逻辑 4. 绘制Snake Javascript数组和DOM操作 创建Snake Head，定义速度常量 移动Snake Head 使用Javascript事件控制Snake方向 创建Snake Body并绘制蛇的身体 6. 绘制Food Javascript数组和DOM操作 使用Javascript DOM创建Food Javascript创建随机数 根据随机数位置显示Food 7. Snake和Food Snake吃Food，Snake增长逻辑 7. 游戏结束 Snake移动范围边界判断 游戏结束判断","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-Grid布局","slug":"JavaScript/snake-grid","date":"2022-07-17T01:19:56.022Z","updated":"2022-07-17T03:23:22.864Z","comments":true,"path":"2022/07/17/JavaScript/snake-grid/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-grid/","excerpt":"","text":"CSS Grid网格布局 在贪吃蛇游戏中，我们使用了CSS中的Grid网格布局，如果不用Grid，你可以使用Canvas绘图。其实在其它编程语言的UI设计中，早已有此类布局方案,比如Java中的GridLayout，感觉CSS把后端语言的UI设计又重新走一遍，而且进展还比较慢 , 多年以前我们还只能使用position,float和各种骇客技术实现布局,直至出现Flex、Grid才真正意义上的解脱； 网格布局示例图 HTML结构 需要将想要控制的元素包装在父容器DIV中 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;div4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 让我们为div添加一些样式，这样就可以轻松地区分不同盒子,这里使用了 display:grid，也就是网格布局 123456789101112.wrapper &gt; div &#123; background-color: orange; border: 1px black solid;&#125; .wrapper &gt; div:nth-child(odd) &#123; background-color: indianred;&#125; .wrapper&#123; display: grid&#125; Grid-template-columns 和 Grid-template-rows grid-template-columns 规则对于grid网格布局，我们首先需要了解的是 grid-template-columns 和 grid-template-rows 这两条规则。这两条规则控制了网格的形状。这些规则的值可以是长度、百分比或网格中空闲空间的一部分。还可以将它们设置为auto，这样做将会填充div盒子的剩余的空间。看例子: 1234.wrapper&#123; display: grid; grid-template-columns: 100px 100px 100px&#125; 上面代码片断中我们设置了三列，每列100px, 但是wrapper下有四个div,所以会有一个div换行显示， display的值还可以设置为inline-grid 修改一下中间设置为auto 1234.wrapper&#123; display: grid; grid-template-columns: 100px auto 100px&#125; 上面代码中，中间值使用了auto, 那么中间那个div将填充所有剩余部分 也可以使用fr, 网格布局提供了fr(fraction片段的意思)，它用于表示比例关系，如果列宽度都为1fr , 那么将平分此行 1234.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr;&#125; 上面代码中将一行分为四列，每列宽度一样 修改一下值 1234.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 3fr 1fr;&#125; 可以看出第二列是第一列的2倍，第三列的大小是前面二列的和; 试着修改最后一列的大小 grid-template-columns 和 grid-template-rows 规则12345.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 50px 50px;&#125; 上面定义二行二列，每一行的高度都为50px, 如果将第一个50px改成其它值如30px, 那么第一行高度将为30px 12345.wrapper &#123; display: grid; grid-template-columns: 100px 20px 250px; grid-template-rows: 150px 40px;&#125; 上面定义二行三列，第一行高150px, 第二行高40px, 前面3个div成为一行中三列，最后一个div单独一行 grid-template 重复规则： Repeat如果你的网格布局中有一个重复的元素，你可以使用repeat并告诉它重复多少次相同的元素。例如，假设你有12个元素，你想让它们以相同的宽度水平放置。您可以在grid-template-column使用repeat(12, 1fr)。 也可以像下面这样 1234.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr 5fr 10fr);&#125; 上面代码中重复4个div元素，1，2，3是第一部分，分别为1fr, 5fr, 10fr; 后续依此类推 Grid-auto-columns 和 Grid-auto-rows 规则此规则帮助你设置网格单元格的宽度和高度。如果不设置此规则，网格的行和列将根据内容展开。 12345.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 100px;&#125; 上面代码重复4个元素，因为总共有12个元素，所以拆分成了3行，每行100px高 12345.wrapper &#123; display: grid; grid-template-columns: repeat(6, 1fr); grid-auto-rows: 100px;&#125; 上面代码重复6个元素，因为总共有12个元素，所以拆分成了2行，每行100px高 12345.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 20px 40px 60px;&#125; minmax() 函数网格自动规则的一个很好的特性是minmax函数。只需将最小值设置为第一个参数，将最大值设置为第二个参数。如果将第二个参数设置为auto，则会得到响应式单元格大小。 12345.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: minmax(50px, auto) &#125; 以上两个结果是CSS相同，div中内容不同的情况 Grid-gap 顾名思义，该规则在网格单元格之间创建了一个间隙(gap)。如果你使用grid-gap: 5px，你会在每个单元格之间得到5px的间隙。或者，只能设置行或列间隙，分别为grid-row-gap: 5px和grid-column-gap: 5px。 123456.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: minmax(50px, auto); grid-gap: 5px; &#125; 子div元素规则 到目前为止，我们只关注网格的形状和在网格中流动的项。现在我们将学习如何单独控制每一项。 为了定位每一项，我们使用网格线作为参考。下面是2x4网格的行和列，分别用黑色和橙色表示。 使用带有行号的 grid-column 和 grid-row 规则来定位元素。 例如，如果我们为第一个子div设置grid-column: 1/3，它将使用网格中的前两个单元格, 也就是第1格到第3格，但不包含第3格, 这种做法类似于在Excel中的列合并。 grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 123456789.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 100px; grid-gap: 5px; &#125;.div1&#123; grid-column: 1/3;&#125; 1234.div1 &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 1234567891011.div1 &#123; grid-column: 1 / 3; /*占用 1~2 列, 也就是跨列*/ grid-row: 1 / 2;&#125;/* 等同于 */.div1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 再看下面示例，div1元素跨列和行 1234.div1&#123; grid-column: 1/3; grid-row: 1/3;&#125; 也可以使用grid-arge 123.div1&#123; grid-area: 2/2/3/4;&#125; Grid-area 和 grid-template-areas 下面的示例稍复杂一点 12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;header&quot;&gt;页头&lt;/div&gt; &lt;div class=&quot;leftCol&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;rightCol&quot;&gt;右侧&lt;/div&gt; &lt;div class=&quot;midTop&quot;&gt;中间上方&lt;/div&gt; &lt;div class=&quot;midBottom&quot;&gt;中间下方&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;页脚&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041.header&#123; grid-area: header; background-color: LightSeaGreen ; &#125; .leftCol&#123; grid-area: leftCol; background-color: orange; &#125; .rightCol&#123; grid-area: rightCol; background-color: lightblue; &#125; .midTop&#123; grid-area: midTop; background-color: lightgrey; &#125; .midBottom&#123; grid-area: midBottom; background-color: pink; &#125; .footer&#123; grid-area: footer; background-color: lightgreen; &#125;.wrapper &#123; display: grid; grid-template-columns: 1fr 4fr 4fr 1fr; grid-template-rows: 50px 100px 100px 30px; grid-template-areas: &quot;header header header header&quot; &quot;leftCol midTop midTop rightCol&quot; &quot;leftCol midBottom midBottom rightCol&quot; &quot;footer footer footer footer&quot;; grid-gap: 5px; &#125; 布局结果 如果想让页脚只取两列并居中，那么我只需在网格模板区域中用点(.)替换页脚的第一个和最后一个。 1234567891011.wrapper &#123; display: grid; grid-template-columns: 1fr 4fr 4fr 1fr; grid-template-rows: 50px 100px 100px 30px; grid-template-areas: &quot;header header header header&quot; &quot;leftCol midTop midTop rightCol&quot; &quot;leftCol midBottom midBottom rightCol&quot; &quot;. footer footer .&quot;; grid-gap: 5px; &#125; 你需要grid Grid 布局还有很多其它属性，可以参考官方文档， 有了上述基础，我们就可以画出贪吃蛇游戏的界面了，马上为你呈现使用Grid有多么简单","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-ES6模块化","slug":"JavaScript/snake-es6module","date":"2022-07-17T01:19:55.830Z","updated":"2022-07-17T03:23:15.072Z","comments":true,"path":"2022/07/17/JavaScript/snake-es6module/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-es6module/","excerpt":"","text":"贪吃蛇-ES6模块化 在后续内容中，我们逐渐在游戏面板上绘制蛇和食物，将会涉及到 javascript DOM技术、ES6中的模块化、箭头函数等知识，所以我们先简单地把要用到的知识点了解和应用。如果需要全面了解，请移步相关官方文档。或者与我私聊，嘿嘿！ 游戏核心逻辑模块化: 使用ES6模块化 现代浏览器基本上都支持ES6模块化(有关ES6的基础知识，可参考阮一峰老师ECMAScript 6入门), 首先我们创建一个main.js文件，这个文件是游戏的入口，只需要在HTML页面上引入main.js，main.js文件内的逻辑先不管，可以先创建一个空文件。关键代码如下: 1&lt;script src=&quot;main.js&quot; defer type=&quot;module&quot; &gt;&lt;/script&gt; defer(延期，推迟) defer属性的意思是HTML页面渲染完成,同时页面中其它脚本也执行完成后脚本文件才会执行, 如果有多个脚本文件都声明了defer, 这些脚本的加载顺序会按照它们在HTML页面上出现的顺序 async(异步) 声明了这个属性的JS脚本一旦下载完成就会立即执行, 如果多个脚本文件都声明了async, 那么它并不能保证按出现的顺序加载 type=”module” 表示让浏览器知晓这是一个ES6模块 模块化在Java中有import，nodejs中也有require, python中有import, 在ES6之前，我在前端开发中会使用CommonJS、requireJS、seaJS等进行模块化, Javascript终于不用第三方插件也可以模块化了，意外地开心，但必须强调一点，使用它还需要浏览器支持才行。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;贪吃蛇游戏&lt;/title&gt; &lt;style&gt; body &#123; height: 100vh; width: 100vw; display: flex; flex-direction: row; justify-content: left; align-items: center; margin: 0; background-color: black; &#125; #game-board &#123; background-color: rgb(250, 245, 245); width: 100vmin; height: 100vmin; display: grid; grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr); &#125; #settings &#123; display: grid; &#125; &lt;/style&gt; &lt;script src=&quot;main.js&quot; defer type=&quot;module&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;game-board&quot;&gt; &lt;/div&gt; &lt;div id=&quot;settings&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下面创建一个snake.js蛇模块和food.js食物模块， 暂时仅在里边定义update和draw函数, update函数实现蛇的变化逻辑， 比如蛇的移动方向以及它的长度变化; draw函数实现蛇的绘制。 food.js类似 snake.js 1234567function update() &#123; console.log(&#x27;更新蛇&#x27;)&#125;function draw() &#123; console.log(&#x27;绘制蛇&#x27;)&#125;export &#123;update, draw&#125; food.js 1234567function update() &#123; console.log(&#x27;更新食物&#x27;)&#125;function draw() &#123; console.log(&#x27;绘制食物&#x27;)&#125;export &#123;update, draw&#125; 上面两个文件都用到了export关键词，用于导出模块中的内容 main.js实现，会用到之前文章中讲到的window.requestAnimationFrame,游戏界面需要不断更新并重绘 , 先使用import 导入snake.js, food.js, 这两个文件和main.js是在同一个目录下， 导入时使用 as 给出一个别名以便在main.js中使用 123456789101112131415161718192021222324//引入 snake.js 和 food.js模块内容 import &#123;update as updateSnake, draw as drawSnake&#125; from &#x27;./snake.js&#x27;import &#123;update as updateFood, draw as drawFood&#125; from &#x27;./food.js&#x27;function main(currentTime) &#123; //再次请求动画帧 window.requestAnimationFrame(main) //调用本模块中的update和draw函数 update() draw()&#125;//请求动画帧window.requestAnimationFrame(main)//因为有蛇和食物需要更新，所以定义了update函数，在函数内部调用另外两个模块的函数function update() &#123; updateSnake() updateFood()&#125;//因为有蛇和食物需要绘制，所以定义了draw函数，在函数内部调用另外两个模块的函数function draw() &#123; drawSnake() drawFood()&#125; 可以将这些代码整合到vscode开发工具中，再运行index.html文件，在浏览器控制台查看效果。 下一篇我们看如何使用DOM绘制蛇和食物。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-使用DOM画蛇","slug":"JavaScript/snake-dom","date":"2022-07-17T01:19:55.828Z","updated":"2022-07-17T03:23:08.867Z","comments":true,"path":"2022/07/17/JavaScript/snake-dom/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-dom/","excerpt":"","text":"使用DOM画蛇 上一篇中我们将整个游戏划分了模块，主要有main.js, snake.js, food.js三个模块，然后在main模块中使用了window.requestAnimationFrame()请求动画帧函数, 通过这个函数不断重复调用update()和draw()函数，这两个函数用于更新界面和重绘游戏中的蛇和食物, 到现在为止并没有实现这两个函数的具体功能，在这一篇中我们将使用JavaScript DOM技术把蛇画出来。 JavaScript DOM DOM 全称文档对象模型，在前端是将WEB页面和JavaScript脚本语言连接起来，提供了一套API（应用程序编程接口）用于操作HTML元素、处理事件等，在贪吃蛇游戏中我们需要用到几个DOM API来创建蛇和食物： 怎样获取HTML元素? 12document.getElementById();document.querySelector(); 怎样创建HTML元素? 1document.createElement() 怎样修改元素的样式属性？ 123元素.style = ...元素.className = ...元素.classList.add(...) 怎样添加元素? 1元素.appendChild(其它元素) JavaScript中如何定义数组? 1const snakeBody = [ 数组内容 ] 绘制蛇身体和头部 HTML代码就不重复了，先在main.js文件中获取网页中id为game-board的元素， 然后再绘制蛇或食物的时候需要传递这个HTML元素给drawSnake方法， 关键代码如下： 获取HTML元素的关键代码 123let gameBoard = document.getElementById(&#x27;game-board&#x27;)//或者let gameBoard = document.querySelector(&#x27;#game-board&#x27;) 调用绘制蛇和食物的关键代码 12drawSnake(gameBoard)drawFood(gameBoard) 完整代码如下: 1234567891011121314151617181920212223242526272829//引入 snake.js 和 food.js模块内容 import &#123;update as updateSnake, draw as drawSnake&#125; from &#x27;./snake.js&#x27;import &#123;update as updateFood, draw as drawFood&#125; from &#x27;./food.js&#x27;/* 通过getElementById获取元素 */let gameBoard = document.getElementById(&#x27;game-board&#x27;)function main(currentTime) &#123; //再次请求动画帧 window.requestAnimationFrame(main) //调用本模块中的update和draw函数 update() draw()&#125;//请求动画帧window.requestAnimationFrame(main)//因为有蛇和食物需要更新，所以定义了update函数，在函数内部调用另外两个模块的函数function update() &#123; updateSnake() updateFood()&#125;//因为有蛇和食物需要绘制，所以定义了draw函数，在函数内部调用另外两个模块的函数function draw() &#123; //画蛇 在game.js模块中drawSnake和drawFood 是一个别名 drawSnake(gameBoard) //画食物 drawFood(gameBoard)&#125; 下面将会在snake.js模块中实现draw方法 在snake.js模块中需要定义蛇，我们使用一个数组来表示，数组中的每一个元素代表蛇的每一个部分的坐标位置，包括x和y, 因为game-board采用的是网格布局，所以每一项（也就是单元格) 都有固定的坐标, 这个坐标(x,y)不能为0，也不能超过在CSS中设定的网格数(网页中设定的是50) : 123456789101112131415161718#game-board &#123; background-color: rgb(250, 245, 245); width: 100vmin; height: 100vmin; display: grid; grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr);&#125;/* 蛇头样式, 使用图片，来源 https://www.iconfont.cn/ */.snake-head &#123; background-image: url(&#x27;./images/head1.png&#x27;); background-size: cover;&#125;/* 蛇身子样式 */.snake-body &#123; background-color: hsl(200,100%,50%); border-radius: 80%;&#125; 蛇用一个对象数组表示，数组中的每个对象表示蛇的一部分 123const snakeBody = [ &#123;x : 2, y : 2&#125;,] 在draw函数中根据snakeBody数组的大小创建多个div元素，用于显示蛇，蛇的长度在后面的游戏过程中会要增加，所以这个snakeBody数组会动态改变大小, 创建div元素并设定它的样式代码如下: 12345678910111213//创建一个div元素const snakeElement = document.createElement(&#x27;div&#x27;)//设置div元素的样式, 使用style//行位置snakeElement.style.gridRowStart = snakeBody[0].x//列位置snakeElement.style.gridColumnStart = snakeBody[0].y//背景颜色snakeElement.style.backgroundColor = &#x27;hsl(200,100%,50%)&#x27;//边框snakeElement.style.border = &#x27;.25vmin solid black&#x27;//将蛇添加到gameBoard元素中gameBoard.appendChild(snakeElement) 通过循环画蛇，一开始仅有一个蛇头，可以自行在snakeBody中添加对象并查看效果 123456789101112131415for(var i=0;i&lt;=snakeBody.length;i++) &#123; //创建一个div元素 const snakeElement = document.createElement(&#x27;div&#x27;) //设置div元素的样式, 使用style //行位置 snakeElement.style.gridRowStart = snakeBody[i].x //列位置 snakeElement.style.gridColumnStart = snakeBody[i].y //背景颜色 snakeElement.style.backgroundColor = &#x27;hsl(200,100%,50%)&#x27; //边框 snakeElement.style.border = &#x27;.25vmin solid black&#x27; //将蛇添加到gameBoard元素中 gameBoard.appendChild(snakeElement)&#125; 实现的代码删除和背景颜色和边框，使用classList.add方法添加样式，snake.js完整代码如下 12345678910111213141516171819202122232425262728function update() &#123; console.log(&#x27;更新蛇&#x27;)&#125;function draw(gameBoard) &#123; for(var i=0;i&lt;=snakeBody.length;i++) &#123; //创建一个div元素 const snakeElement = document.createElement(&#x27;div&#x27;) //设置div元素的样式, 使用style //行位置 snakeElement.style.gridRowStart = snakeBody[i].x //列位置 snakeElement.style.gridColumnStart = snakeBody[i].y if(index == 0) &#123; //为蛇头 添加snake-head样式类 snakeElement.classList.add(&#x27;snake-head&#x27;) //蛇头随着按下不同的方向键进行旋转，getHeadDirection函数后面再实现，此行先注释 //snakeElement.style.transform = &#x27;rotate(&#x27;+getHeadDirection()+&quot;)&quot; &#125; else &#123; //为蛇身体添加样式类 snakeElement.classList.add(&#x27;snake-body&#x27;) &#125; //将蛇添加到gameBoard元素中 gameBoard.appendChild(snakeElement) &#125;&#125;export &#123;update, draw&#125; 画食物的函数在这里就没有贴出代码，可以自己参考画蛇的方法完成食物的绘制","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-游戏界面","slug":"JavaScript/snake-board","date":"2022-07-17T01:19:55.826Z","updated":"2022-07-17T03:22:24.772Z","comments":true,"path":"2022/07/17/JavaScript/snake-board/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-board/","excerpt":"","text":"贪吃蛇-游戏界面 在编写界面之前，有一些前置知识必须要理解并能熟练使用，比如flex和grid布局， vh、vw、 vmin、 vmax、em、rem、px单位; 有了这些知识，编写游戏界面将变得非常简单，下面我们一步步实现。 HTML设计 只需一个div元素，给它一个id 123&lt;body&gt; &lt;div id=&quot;game-board&quot;&gt;&lt;/div&gt;&lt;/body&gt; body样式 我们需要定义高度和宽度，对整个body元素采用flex布局，主要目的是让其内容居中，并给一些基础样式美化一下；会使用到 display, justify-content, align-items 这些和flex布局相关， vh,vw单位也将使用到 123456789body &#123; height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; margin: 0; background-color: black;&#125; vw、vh、vmin和vmax是CSS3中的视窗单位，也是相对单位。它们的大小都是由视窗大小来决定的，单位1，表示视窗的1%；vw：视窗宽度的百分比， vh：视窗高度的百分比， vmin：当前较小的vw和vh， vmax：当前较大的vw和vh 视窗是指浏览器可视区域的宽和高， 1vm 表示 1%浏览器可视区域的宽，100vm表示整个可视频区域的宽 div游戏面板样式 我们使用到了id选择器 #game-board, 定义了背景颜色，以及宽度和高度， 同时这个游戏界面我们使用网格布局，目的是把蛇的头和身子以及食物都用格子表示 12345678#game-board &#123; background-color: #CCC; width: 100vmin; height: 100vmin; display: grid; grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr);&#125; 使用了行列均为50格子的网格布局 grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr); 蛇和食物样式 123456789.snake &#123; border: .20vmin solid black; background-color: hsl(200, 100%, 50%);&#125;.food &#123; border: .20vmin solid black; background-color: hsl(50, 100%, 50%);&#125; 就这么简单, 蛇和食物都需要使用Javascript动态创建，后续就是Javascript编码了","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"JOOQ&DSL","slug":"JOOQ/JOOQ","date":"2022-07-17T01:19:55.806Z","updated":"2021-11-26T08:44:57.053Z","comments":true,"path":"2022/07/17/JOOQ/JOOQ/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JOOQ/JOOQ/","excerpt":"","text":"​ 为了更”懒”一点，程序员们发明了各种ORM框架，从繁琐的SQL中解放了出来，但产生的副作用便是需要学习一套的对象和关系映射的API，再加上一堆的XML配置或是感觉不那么舒服的注解。 ​ 相比开发中主流的ORM开发框架Hibernate、MyBatis/MyBatisPlus， JOOQ(Java Object Oriented Query), 是一个不那么广泛应用的ORM&amp;DSL(Domain Specific Language)框架。 ​ 使用它必定有强大的理由，也就是说JOOQ解决了哪些开发中的哪些痛点，长时间以来我们使用Hibernate/MyBatis来服务开发中的数据查询、持久化等功能，虽然都能在一定程度上提升生产率，让开发人员专注于业务，但在实践中复杂且并不易维护的XML配置让人抓狂，复杂的判断逻辑操作几乎需要纯手工打造。那么使用JOOQ的理由便正如它官网(jooq.org)上的那句: Our customers spend most time on their business-logic.Because jOOQ takes care of all their Java/SQL infrastructure problems. JOOQ的优点： Database First：数据库优先，和MyBatis一样提供灵活的不隐藏SQL的方式，用Java代码的风格编写SQL语句 Typesafe SQL：将SQL建模为内部DSL，并使用Java编译器编译SQL语法、元数据和数据类型 Code Generation：它从数据库元数据生成Java类。当代码与模式不同步时，Java编译器会告诉你 Active Records：允许你直接在ActiveRecords上执行CRUD和POJO映射，这些ActiveRecords也是由代码生成器生成的 Multi-Tenancy：允许你在运行时配置数据库模式和表覆盖，还支持行级安全性 Standardisation：将常见的SQL表达式转换为数据库中最接近的匹配。编写适用于所有数据库的SQL Query Lifecycle：让你的程序与它的SQL生成生命周期挂钩，用于日志记录、事务处理、ID生成、SQL转换等 Procedures：允许你将存储的函数调用嵌入到SQL语句中 jOOQ的缺点： 对开源数据库免费，对商业数据库收费 一系列的总结记录jOOQ使用方法，以便查询","categories":[{"name":"JOOQ","slug":"JOOQ","permalink":"https://zhsunbeam.github.io/categories/JOOQ/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"ORM框架","slug":"ORM框架","permalink":"https://zhsunbeam.github.io/tags/ORM%E6%A1%86%E6%9E%B6/"}]},{"title":"H5“面子”-盒子与边框","slug":"H5CSS3/H5-box-border","date":"2022-07-17T01:19:55.804Z","updated":"2021-12-09T05:10:47.947Z","comments":true,"path":"2022/07/17/H5CSS3/H5-box-border/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/H5CSS3/H5-box-border/","excerpt":"","text":"​ 想成为一名更赚钱的WEB开发工程师，当然没问题，H5和CSS3了解一下，噢，可不能简单了解，技术上你需要深入理解盒子模型、JavaScript编程逻辑、HTTP协议、IP和域名等; 设计上你需要搞定颜色搭配、字体风格、各种类型的图片处理、整体布局设计等等; 如果仅仅是制作几个只有你自己看的页面，那就简单了；可多数时候我们是要将成果拿给客户看，怎么办？现成的UI组件救开发人员于水火：Bootstrap、ElementUI、weui等等，但是学习这些UI组件库成本也不低(主要是好多英文单词)，如果对Java中的awt/Swing、JavaFX, C++中的MFC界面库、Qt等客户端界面设计有过经验，学习起来自然顺风顺水，毕竟这些优秀的设计方法在前端又会要从头来一遍； H5设计页面 HTML5共有一百多个标签，需要都记住吗？No，实际上常用的标签也就那么十几二十个， 标签很容易使用，基本无门槛；难点在于CSS的设计，特别是排版，当然现在已有更方便的flex、grid, 那么还有什么问题呢? 英语单词比较多,单词量还可以的朋友可以直接忽略这个问题，另外就是你需要将制作的页面发布到服务器，至少不是只有自己欣赏。 使用非常频繁的标签, 记住它们的基本属性 div, span, ul, li, table, a, p, form, input(type=text|checkbox|radio|password), button, select/option, textarea header, footer, section, article, aside, details, nav 设计页面时常用的样式 定位： position, display, float, clear 背景： background-color, background-image, background-repeat, background-position,background-size, background-attachment, background 字体：font-family, font-size, font-style, font-weight, font-variant, font 单位： px, rpx, em, rem 边框： border, border-width, border-style, border-color 盒子模型 样式 border, margin, padding 其它常见单词 content, left, right, top, bottom w3c.org 官网盒子模型图 盒子与边框、内容有一个观念必须建立，那就是不管你的写的元素是什么，它都是一个盒子，无论是文本还是按钮，div或是span，对CSS来说每一个元素都是盒子， 每个盒子都有文本以及边框等，我们需要知道这些不同部分之间的关系，同时也要明白盒子和盒子之间的关系如何定义 123456789101112131415161718192021* &#123; padding: 0; margin: 0; font-size: 40px;&#125;.box-one &#123; background-color: #EB5757; border: 0px solid #9B51E0; padding: 0px; margin: 0px;&#125;.box-two &#123; background-color: aqua; border: 0px solid seagreen; padding: 0px; margin: 0px;&#125;&lt;body&gt; &lt;div class=&quot;box-one&quot;&gt;One&lt;/div&gt; &lt;div class=&quot;box-two&quot;&gt;Two&lt;/div&gt;&lt;/body&gt; 效果如下图所示， 一个盒子实际所占有的宽度和高度是由 “内容(content)+内边距(padding)+边框(border)+外边距(margin)”组成, 对任何盒子都可以分别设定4条边各自的border、padding、margin, 注意外部元素body也是一个盒子 我们可以修改盒子的border以及padding和margin 123456789101112.box-one &#123; background-color: #EB5757; border: 20px solid #9B51E0; padding: 20px; margin: 30px;&#125;.box-two &#123; background-color: aqua; border: 20px solid seagreen; padding: 20px; margin: 30px;&#125; 再看看计算后的盒子模型， 可以看到四个边的border(20)、padding(20)、margin(30)的大小,也可以单独设置某一边的距离，比如设置padding-left: 30px 下面给盒子设置宽度和高度,再查看一下计算结果,如果不设置width和height，默认根据文字大小自动设定 12345678.box-one &#123; background-color: #EB5757; border: 20px solid #9B51E0; padding: 20px; margin: 30px; width: 100px; height: 100px;&#125; 设置了宽度之后，可以看到盒子大小改变成100x100, 这个宽和高设置的实际上是指Content(内容)的大小, 有另一个属性可以改变，那就是box-sizing: content-box|border-box 123456789.box-one &#123; background-color: #EB5757; border: 20px solid #9B51E0; padding: 20px; margin: 30px; width: 100px; height: 100px; box-sizing: border-box;&#125; 可见，如果设置box-sizing: border-box; width设定为100,那么 border+padding+content=100, 此时文字太大，就会超出Content范围 结论 border一般用于分隔不同的元素，border的外围即为元素的最外围，所以计算元素的宽和高时，需要将border计算进来，当然也需要看box-sizing的设置是content-box还是border-box border写法 简写 border: 10px solid #FF9090; 10px是指边框宽, solid是指边框style, #FF9090是指边框颜色 单独写 border-width: 10px; border-style: none|hidden|dotted|dashed|solid|double…; border-color: #FF9090;","categories":[{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/categories/H5/"}],"tags":[{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/tags/H5/"}]},{"title":"玩游戏学前端-贪吃蛇-animationframe","slug":"JavaScript/animationframe","date":"2022-07-17T01:19:55.772Z","updated":"2022-07-17T03:31:07.206Z","comments":true,"path":"2022/07/17/JavaScript/animationframe/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/animationframe/","excerpt":"","text":"window.requestAnimationFrame() 方法 现如今，各种web开发技术被引入来创建漂亮的web页面。当谈到漂亮的网页时，最重要的内容之一就是动画。有很多方法可以生成动画，CSS3是其中之一，但JavaScript一直是一个强大的选项。window.requestAnimationFrame()方法是JavaScript中将简单的动画整合到我们的项目中的方法之一。也可以使用早期的方法，如setTimeout()或setInterval()，这两个方法仍然可用，但是使用起来慢且不太优雅，最主要的问题还是同步，过渡时间慢，而且对游戏项目来说体验较差。 语法 window.requestAnimationFrame( callback 回调函数 ); 参数：此方法接收单个参数 callback, 它是一个回调函数; 除非你想要动画停止，否则你应该编写回调函数，便于发出对下一帧的请求。回调函数接受时间戳或一个时间值，在该时间值处开始执行。 返回值：此方法返回一个非零长整型数值，作为回调函数中动画的唯一标识。 示例1: 元素向右移动 12345678910111213141516171819202122232425262728&lt;div id=&quot;panel&quot;&gt; &lt;h1 style=&quot;color: #d662f3;&quot;&gt;我爱你中国&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; //动画起始时间 var start = null; //获取DIV元素对象 var element = document.getElementById(&#x27;panel&#x27;); //开始动画函数，传入时间戳 function startAnimation(timestamp) &#123; // timestamp表示1970年1月1日开始经过的秒数 // 第一次回调此函数 start 为 null, 进入if块之后重新赋值 if (!start) &#123; start = timestamp; &#125; //时间戳-开始时间 表示流逝的时间 var progress = timestamp - start; // 移动元素，使用transform样式 ,变换 x 坐标 element.style.transform = &#x27;translateX(&#x27; + Math.min(progress / 10, 700) + &#x27;px)&#x27;; //再次请求动画帧 window.requestAnimationFrame(startAnimation); &#125; window.requestAnimationFrame(startAnimation);&lt;/script&gt; 回调函数会收到一个参数，这个参数表示当前时间距离开始触发 requestAnimationFrame 的回调的时间。 示例2: 按下按钮元素向右移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; position: absolute; left: 10px; top: 50px; padding: auto; color: white &#125; h1 &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;button onclick=&quot;start()&quot;&gt;开始动画&lt;/button&gt; &lt;/center&gt; &lt;div id=&quot;panel&quot;&gt;&lt;h1&gt;我爱你中国&lt;/h1&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var x = document.getElementById(&quot;panel&quot;); // 初始化变量 var requestId; var stopped; var starttime; function startAnimation(time) &#123; //如果stopped为空 则设置x元素的样式left if (!stopped) &#123; x.style.left = ((Date.now() - starttime) / 10 % 700) + &quot;px&quot;; //返回id requestId = window.requestAnimationFrame(startAnimation); &#125; &#125; function start() &#123; //当前时间 starttime = Date.now(); //开始动画 requestId = window.requestAnimationFrame(startAnimation); // 设置为false表示动画不会停止 stopped = false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"一个外包项目","slug":"project/一个外包项目","date":"2021-08-22T04:33:52.000Z","updated":"2021-08-22T13:20:12.574Z","comments":true,"path":"2021/08/22/project/一个外包项目/","link":"","permalink":"https://zhsunbeam.github.io/2021/08/22/project/%E4%B8%80%E4%B8%AA%E5%A4%96%E5%8C%85%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"一个外包小项目，利用业余时间赚点零花钱，甲方要求也简单，这种类型的项目其实到处都是，也可以直接做个搬运工， 但需要改成客户想要的样子，花的时间可能更多，而且需要做成多端应用：微信端和PC端，看看分析后的需求内容吧 员工 员工ID、姓名、个人照片、性别(选择，男|女)、籍贯(选择，省|市|区县)、出生年月日(选择)、学历(选择)、手机、住址、邮箱、毕业院校(手动填写)、专业(手动填写)、工作经历、入职时间(年月日)、岗位名称、操作时间、操作人、状态(在职|离职)。 参与角色：员工或者人事专员 员工证件 员工ID、证件名称ID、证件图、状态。需要员工自己上传的为3个证件：学位证、毕业证、其它技能证书、银行卡、入职体检报告，人事专员需要上传一个合同。 参与角色：员工或者人事专员 员工晋级转岗 员工ID、事项类型(试用期|转岗|晋级)、岗位、时间、操作时间、操作人、备注。 参与角色：人事专员 员工离职 员工ID、离职时间、离职原因、操作人、操作时间、是否已打印离职证明、工作交接是否已完成、是否已归还设备及其他。 参与角色：人事专员 员工资产归属 员工ID、资产编号、领用时间、领用操作人、归还时间、归还操作人、备注。 参与角色：资产管理或者人事专员 如果要根据以上需求来建表，怎么玩?","categories":[{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"},{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JOOQ","slug":"JOOQ","permalink":"https://zhsunbeam.github.io/categories/JOOQ/"},{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/categories/H5/"},{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://zhsunbeam.github.io/tags/HTML/"},{"name":"ORM框架","slug":"ORM框架","permalink":"https://zhsunbeam.github.io/tags/ORM%E6%A1%86%E6%9E%B6/"},{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/tags/H5/"},{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}]}