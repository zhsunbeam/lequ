{"meta":{"title":"极乐空间","subtitle":"安静的来点代码","description":"","author":"Mars笑笑生","url":"https://zhsunbeam.github.io","root":"/"},"pages":[{"title":"关于极乐空间","date":"2021-08-10T16:00:00.000Z","updated":"2022-07-17T02:44:51.399Z","comments":true,"path":"about/index.html","permalink":"https://zhsunbeam.github.io/about/index.html","excerpt":"","text":"N 年软件开发/培训老兵，搞项目、技术分享，从前端到后端，从代码到架构，不一而足；常吐槽各类IT机构少则二万多则三四万的培训费，结果却只会CRUD; 练技能不玩虚的；如果您喜欢编程、并有意以此为职业，或许我们可以一起成长，无论线上线下，绝对超值。"},{"title":"分类","date":"2021-08-11T12:30:54.000Z","updated":"2021-08-11T12:50:03.657Z","comments":true,"path":"categories/index.html","permalink":"https://zhsunbeam.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-11T12:41:12.000Z","updated":"2021-08-11T14:31:22.690Z","comments":true,"path":"tags/index.html","permalink":"https://zhsunbeam.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-18T04:06:12.864Z","updated":"2022-07-18T04:06:12.864Z","comments":true,"path":"links/index.html","permalink":"https://zhsunbeam.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"(二) cardGame-扑克牌设计","slug":"JavaScript/cardgame/(2)-cardGame-扑克牌设计","date":"2022-08-24T01:10:16.000Z","updated":"2022-08-25T01:32:11.743Z","comments":true,"path":"2022/08/24/JavaScript/cardgame/(2)-cardGame-扑克牌设计/","link":"","permalink":"https://zhsunbeam.github.io/2022/08/24/JavaScript/cardgame/(2)-cardGame-%E6%89%91%E5%85%8B%E7%89%8C%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"制作一个简单的翻牌游戏， 使用HTML5/CSS3设计界面, Javascript翻牌对比； 麻雀虽小，五脏俱全, 此项目将CSS中常见的技术应用在项目中，使用JavaScript原生开发，设计简单，便于快速掌握CSS3和JavaScript的用法; 某些知识点再通过其它视频或文档去了解，事半功倍。 扑克牌设计1. 扑克牌html结构设计 扑克牌HTML结构设计: 整张牌使用 div 包裹, 样式使用card描述 div.card 包含两个子元素 div, 扑克牌的背面div.card-back和正面div.card-front 不管正面和背面都有同样的样式，使用card-face描述 data-number 和 data-turn 是自定义的以data-开头的属性，方便使用javascript识别 data-number 表示牌的数字值， data-turn用于描述牌显示的是正面还是背面 123456789101112131415&lt;!-- 扑克牌 --&gt;&lt;div class=&quot;card&quot; data-number=&quot;8&quot; data-turn=&quot;back&quot; onclick=&quot;handlerClick(this)&quot;&gt; &lt;!-- 背面 --&gt; &lt;div class=&quot;card-back card-face&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-top-left&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-top-right&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-bottom-left&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-bottom-right&quot;&gt; &lt;img src=&quot;imgs/Spider.png&quot; class=&quot;spider&quot;&gt; &lt;/div&gt; &lt;!-- 数字面 ♠ ♥ ♣ ♦--&gt; &lt;div class=&quot;card-front card-face&quot;&gt; &lt;div class=&quot;card red&quot; data-value=&quot;8 ♠&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625); &#125; /* 标题样式 */ .game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal; &#125; /* 游戏信息文字样式 */ .game-info &#123; color: #F0F4F7; font-size: 3em; &#125; /* 游戏标题容器布局样式 */ .game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px; &#125; /* 内部布局样式 */ .game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;!-- 游戏信息 --&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- game-info-container 结束 --&gt; &lt;!-- 扑克牌 --&gt; &lt;div class=&quot;card&quot; data-number=&quot;8&quot; data-turn=&quot;back&quot; onclick=&quot;handlerClick(this)&quot;&gt; &lt;!-- 背面 --&gt; &lt;div class=&quot;card-back card-face&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-top-left&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-top-right&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-bottom-left&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-bottom-right&quot;&gt; &lt;img src=&quot;imgs/Spider.png&quot; class=&quot;spider&quot;&gt; &lt;/div&gt; &lt;!-- 数字面 ♠ ♥ ♣ ♦--&gt; &lt;div class=&quot;card-front card-face&quot;&gt; &lt;div class=&quot;card red&quot; data-value=&quot;8 ♠&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- game-container 结束 --&gt;&lt;/body&gt;&lt;/html&gt; 结果如下图所示 2. 扑克牌样式和内部布局 在没有定义div.card, div.card-back, div.card-face 等这些样式时，所有蜘蛛网和蜘蛛都是横向排列 div.card样式, 主要是定义好扑克牌的宽度和高度, 还将position设置为relative相对布局，这个就要求对position的用法比较明确 12345678/* 扑克牌 */.card &#123; position: relative; /* 相对位置 */ height: 175px; /* 扑克牌高度 */ width: 125px; /* 扑克牌宽度 */ /* 测试用样式,后面删除 */ border: 1px white solid;&#125; 结果如图 设计div.card-face样式， 不管背面还是正面的通用样式, 此时采用 position:absolute,脱离标准流 123456/* 扑克牌正面和背面通用样式, 两个div层需要重合，使用的是position:absolute */.card-face &#123; position: absolute; width: 100%; /* 相对于父元素宽度 也就是div.card */ height: 100%; /* 相对于父元素高度 也就是div.card */&#125; 结果如图 在上图中，蜘蛛图片显示在了外面，需要让其在div.card-face容器中 设置子元素的布局方式为 flex布局 其它样式为扑克牌正面div和背面div的圆角设计 123456789101112131415161718/* 扑克牌正面和背面通用样式, 两个div层需要重合，使用的是position:absolute */.card-face &#123; position: absolute; width: 100%; /* 相对于父元素宽度 也就是div.card */ height: 100%; /* 相对于父元素高度 也就是div.card */ /* 内部元素的排版布局方式为flex */ display: flex; justify-content: center; align-items: center; overflow: hidden; /* 背面和正面的圆角设计 */ border-radius: 12px; border-width: 1px; border-style: solid; font-size: 7em;&#125; 如图所示 分别设计 背面和正面的不同样式 背景颜色和边框颜色设计，这个比较简单 另外增加了一点transform(变换)动画, 当鼠标悬停在div.card上面时，内部的div.card-back和div.card-front需要沿着Y轴变换 123456789101112131415161718192021222324.card-face &#123; ......省略 /* transform变换动画 */ transition: transform 500ms ease-in-out;&#125;.card-back &#123; background-color: black; border: #FF6D11;&#125;.card-front &#123; background-color: #FFBB88; border-color: #333333; transform: rotateY(180deg);&#125;.card:hover .card-back &#123; transform: rotateY(-180deg);&#125;.card:hover .card-front &#123; transform: rotateY(0);&#125; 效果如图所示： 此时会发现一个问题，也就是牌的背面没有显示，旋转过来之后还是正面 为了解决上面这个问题，我们需要在 div.card类上增加一个CSS3属性backface-visibility, 默认显示的是背面 123456789.card-face &#123; ......省略 /*隐藏背面*/ backface-visibility: hidden; /* transform变换动画 */ transition: transform 500ms ease-in-out;&#125; 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625); &#125; /* 标题样式 */ .game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal; &#125; /* 游戏信息文字样式 */ .game-info &#123; color: #F0F4F7; font-size: 3em; &#125; /* 游戏标题容器布局样式 */ .game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px; &#125; /* 内部布局样式 */ .game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between; &#125; /* 扑克牌 */ .card &#123; position: relative; /* 相对位置 */ height: 175px; /* 扑克牌高度 */ width: 125px; /* 扑克牌宽度 */ /* 测试用样式,后面删除 */ border: 1px white solid; &#125; /* 扑克牌正面和背面通用样式, 两个div层需要重合，使用的是position:absolute */ .card-face &#123; position: absolute; width: 100%; /* 相对于父元素宽度 也就是div.card */ height: 100%; /* 相对于父元素高度 也就是div.card */ /* 内部元素的排版布局方式为flex */ display: flex; justify-content: center; align-items: center; overflow: hidden; /* 背面和正面的圆角设计 */ border-radius: 12px; border-width: 1px; border-style: solid; font-size: 7em; /* 隐藏背面 */ backface-visibility: hidden; /* transform变换动画 */ transition: transform 500ms ease-in-out; &#125; .card-back &#123; background-color: black; border: #FF6D11; &#125; .card-front &#123; background-color: #FFBB88; border-color: #333333; transform: rotateY(180deg); &#125; .card:hover .card-back &#123; transform: rotateY(-180deg); &#125; .card:hover .card-front &#123; transform: rotateY(0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 扑克牌 --&gt; &lt;div class=&quot;card&quot; data-number=&quot;8&quot; data-turn=&quot;back&quot; onclick=&quot;handlerClick(this)&quot;&gt; &lt;!-- 背面 --&gt; &lt;div class=&quot;card-back card-face&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-top-left&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-top-right&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-bottom-left&quot;&gt; &lt;img src=&quot;imgs/Cobweb.png&quot; class=&quot;cobweb cobweb-bottom-right&quot;&gt; &lt;img src=&quot;imgs/Spider.png&quot; class=&quot;spider&quot;&gt; &lt;/div&gt; &lt;!-- 数字面 ♠ ♥ ♣ ♦--&gt; &lt;div class=&quot;card-front card-face&quot;&gt; &lt;div class=&quot;card red&quot; data-value=&quot;8 ♠&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 本篇我们利用CSS中position, display，动画等技术，实现了扑克牌翻转，背后的知识可以查看相关文档。下篇中再来实现背面蜘蛛图片的布局","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML5/CSS3","slug":"HTML5-CSS3","permalink":"https://zhsunbeam.github.io/tags/HTML5-CSS3/"}]},{"title":"(一) cardGame-界面设计","slug":"JavaScript/cardgame/(1)-cardGame-界面设计","date":"2022-08-24T01:02:06.000Z","updated":"2022-08-24T03:08:39.792Z","comments":true,"path":"2022/08/24/JavaScript/cardgame/(1)-cardGame-界面设计/","link":"","permalink":"https://zhsunbeam.github.io/2022/08/24/JavaScript/cardgame/(1)-cardGame-%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"制作一个简单的翻牌游戏， 使用HTML5/CSS3设计界面, Javascript翻牌对比； 麻雀虽小，五脏俱全, 此项目将CSS中常见的技术应用在项目中，使用JavaScript原生开发，设计简单，便于快速掌握CSS3和JavaScript的用法; 某些知识点再通过其它视频或文档去了解，事半功倍。 设计页面1. 设计页面中的游戏标题、倒计时、点击次数 先设计好HTML结构，HTML结构中每个元素先预定好class类选择器的名字 在页面相同目录下创建fonts目录，将字体文件 恐怖蜘蛛.ttf 放在里面 在style标签中 使用@font-face引用字体 页面中盒子计算方式为 boder-box 将页面字体设计为 自定义的 “蜘蛛” 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;!-- 游戏倒计时和点击次数设计 --&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果如下图所示 2. 游戏标题和信息排版布局 设计一个背景，让颜色感觉恐怖一点，这是我设置成暗红，使用了CSS3中的渐变 1234body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625);&#125; 设计游戏标题的基础CSS，其实也就是颜色、字体大小、字体粗细、文本的位置等等, 这些也是常用的CSS样式 游戏信息的文字颜色和大小也需要设计 12345678910.game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal;&#125;.game-info &#123; color: #F0F4F7; font-size: 3em;&#125; 游戏信息这部分的布局，设计了三个样式 game-container,game-info-container, game-info game-container是游戏信息最上层的容器, 选择grid网格布局，内容居中，格子之间定义一定的间隙 关于grid 网格布局，后续会有详细的案例来说明, 也可以查看CSS3文档 123456.game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px;&#125; game-info-container这个容器的布局采用 flex, 让两个文字最终会显示在两端 12345.game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between;&#125; 完整代码和效果图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625); &#125; /* 标题样式 */ .game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal; &#125; /* 游戏信息文字样式 */ .game-info &#123; color: #F0F4F7; font-size: 3em; &#125; /* 游戏标题容器布局样式 */ .game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px; &#125; /* 内部布局样式 */ .game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下一篇中来设计一下扑克牌，也会用到常见的CSS样式，特别是position, z-index, 过渡效果等","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML5/CSS3","slug":"HTML5-CSS3","permalink":"https://zhsunbeam.github.io/tags/HTML5-CSS3/"}]},{"title":"(一) cardGame-界面设计","slug":"JavaScript/cardgame/(3)-cardGame-倒计时","date":"2022-08-24T01:02:06.000Z","updated":"2022-08-24T03:08:39.792Z","comments":true,"path":"2022/08/24/JavaScript/cardgame/(3)-cardGame-倒计时/","link":"","permalink":"https://zhsunbeam.github.io/2022/08/24/JavaScript/cardgame/(3)-cardGame-%E5%80%92%E8%AE%A1%E6%97%B6/","excerpt":"","text":"制作一个简单的翻牌游戏， 使用HTML5/CSS3设计界面, Javascript翻牌对比； 麻雀虽小，五脏俱全, 此项目将CSS中常见的技术应用在项目中，使用JavaScript原生开发，设计简单，便于快速掌握CSS3和JavaScript的用法; 某些知识点再通过其它视频或文档去了解，事半功倍。 设计页面1. 设计页面中的游戏标题、倒计时、点击次数 先设计好HTML结构，HTML结构中每个元素先预定好class类选择器的名字 在页面相同目录下创建fonts目录，将字体文件 恐怖蜘蛛.ttf 放在里面 在style标签中 使用@font-face引用字体 页面中盒子计算方式为 boder-box 将页面字体设计为 自定义的 “蜘蛛” 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;!-- 游戏倒计时和点击次数设计 --&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果如下图所示 2. 游戏标题和信息排版布局 设计一个背景，让颜色感觉恐怖一点，这是我设置成暗红，使用了CSS3中的渐变 1234body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625);&#125; 设计游戏标题的基础CSS，其实也就是颜色、字体大小、字体粗细、文本的位置等等, 这些也是常用的CSS样式 游戏信息的文字颜色和大小也需要设计 12345678910.game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal;&#125;.game-info &#123; color: #F0F4F7; font-size: 3em;&#125; 游戏信息这部分的布局，设计了三个样式 game-container,game-info-container, game-info game-container是游戏信息最上层的容器, 选择grid网格布局，内容居中，格子之间定义一定的间隙 关于grid 网格布局，后续会有详细的案例来说明, 也可以查看CSS3文档 123456.game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px;&#125; game-info-container这个容器的布局采用 flex, 让两个文字最终会显示在两端 12345.game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between;&#125; 完整代码和效果图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625); &#125; /* 标题样式 */ .game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal; &#125; /* 游戏信息文字样式 */ .game-info &#123; color: #F0F4F7; font-size: 3em; &#125; /* 游戏标题容器布局样式 */ .game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px; &#125; /* 内部布局样式 */ .game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下一篇中来设计一下扑克牌，也会用到常见的CSS样式，特别是position, z-index, 过渡效果等","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML5/CSS3","slug":"HTML5-CSS3","permalink":"https://zhsunbeam.github.io/tags/HTML5-CSS3/"}]},{"title":"(一) cardGame-界面设计","slug":"JavaScript/cardgame/(4)-cardGame-扑克牌比较大小","date":"2022-08-24T01:02:06.000Z","updated":"2022-08-24T03:08:39.792Z","comments":true,"path":"2022/08/24/JavaScript/cardgame/(4)-cardGame-扑克牌比较大小/","link":"","permalink":"https://zhsunbeam.github.io/2022/08/24/JavaScript/cardgame/(4)-cardGame-%E6%89%91%E5%85%8B%E7%89%8C%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"制作一个简单的翻牌游戏， 使用HTML5/CSS3设计界面, Javascript翻牌对比； 麻雀虽小，五脏俱全, 此项目将CSS中常见的技术应用在项目中，使用JavaScript原生开发，设计简单，便于快速掌握CSS3和JavaScript的用法; 某些知识点再通过其它视频或文档去了解，事半功倍。 设计页面1. 设计页面中的游戏标题、倒计时、点击次数 先设计好HTML结构，HTML结构中每个元素先预定好class类选择器的名字 在页面相同目录下创建fonts目录，将字体文件 恐怖蜘蛛.ttf 放在里面 在style标签中 使用@font-face引用字体 页面中盒子计算方式为 boder-box 将页面字体设计为 自定义的 “蜘蛛” 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;!-- 游戏倒计时和点击次数设计 --&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果如下图所示 2. 游戏标题和信息排版布局 设计一个背景，让颜色感觉恐怖一点，这是我设置成暗红，使用了CSS3中的渐变 1234body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625);&#125; 设计游戏标题的基础CSS，其实也就是颜色、字体大小、字体粗细、文本的位置等等, 这些也是常用的CSS样式 游戏信息的文字颜色和大小也需要设计 12345678910.game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal;&#125;.game-info &#123; color: #F0F4F7; font-size: 3em;&#125; 游戏信息这部分的布局，设计了三个样式 game-container,game-info-container, game-info game-container是游戏信息最上层的容器, 选择grid网格布局，内容居中，格子之间定义一定的间隙 关于grid 网格布局，后续会有详细的案例来说明, 也可以查看CSS3文档 123456.game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px;&#125; game-info-container这个容器的布局采用 flex, 让两个文字最终会显示在两端 12345.game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between;&#125; 完整代码和效果图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;翻牌游戏&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &quot;蜘蛛&quot;; src: url(fonts/恐怖蜘蛛.ttf) format(&quot;truetype&quot;); &#125; /* 盒子的计算方式 */ * &#123; box-sizing: border-box; &#125; /* 设置整个页面的字体，最小宽度和最小高度,单位使用vw,vh */ html &#123; font-family: &quot;蜘蛛&quot;, serif; min-width: 100vw; min-height: 100vh; &#125; body &#123; margin: 0; background: radial-gradient(#F15F66, #7E2625); &#125; /* 标题样式 */ .game-title &#123; color: #EBD408; text-align: center; font-size: 4em; font-weight: normal; &#125; /* 游戏信息文字样式 */ .game-info &#123; color: #F0F4F7; font-size: 3em; &#125; /* 游戏标题容器布局样式 */ .game-container &#123; display: grid; grid-template-columns: repeat(4, auto); justify-content: center; gap: 10px; &#125; /* 内部布局样式 */ .game-info-container &#123; grid-column: 1 / -1; display: flex; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 游戏标题设计 --&gt; &lt;h1 class=&quot;game-title&quot;&gt;翻牌游戏&lt;/h1&gt; &lt;div class=&quot;game-container&quot;&gt; &lt;div class=&quot;game-info-container&quot;&gt; &lt;div class=&quot;game-info&quot;&gt; 倒计时: &lt;span id=&quot;timeRemaining&quot; class=&quot;time-remaining&quot;&gt;60&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;game-info&quot;&gt; 点击次数: &lt;span id=&quot;clickCount&quot; class=&quot;click-count&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下一篇中来设计一下扑克牌，也会用到常见的CSS样式，特别是position, z-index, 过渡效果等","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML5/CSS3","slug":"HTML5-CSS3","permalink":"https://zhsunbeam.github.io/tags/HTML5-CSS3/"}]},{"title":"JavaFX汉诺塔","slug":"Java/JavaFX汉诺塔","date":"2022-08-01T05:05:19.000Z","updated":"2022-08-06T03:51:30.385Z","comments":true,"path":"2022/08/01/Java/JavaFX汉诺塔/","link":"","permalink":"https://zhsunbeam.github.io/2022/08/01/Java/JavaFX%E6%B1%89%E8%AF%BA%E5%A1%94/","excerpt":"","text":"汉诺塔（Tower of Hanoi），是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。本文使用JavaFX模拟汉诺塔，使用了Java面向对象，Java stream和Optional, JavaFX图形技术, 包含Stage、Scene、事件处理、Pane、StackPane等，要求对Java8以上版本的特性有了解。一起来实现这个小游戏吧! 效果图 游戏逻辑 创建三个塔，使用三个矩形模拟三个塔 在第一个矩形周围绘制多个圆形表示圆盘 点击塔中的圆盘选中后，再点击其它塔，移动圆盘到其它塔 直到将所有圆盘按从小到大的顺序显示在第三个塔上 一、创建一个Application Stage 舞台 Scene 场景 Pane容器用于存放绘制的形状 123456789101112131415public class TowerHanoi extends Application &#123; @Override public void start(Stage stage) throws Exception &#123; stage.setScene(new Scene(createContent())); stage.show(); &#125; private Parent createContent() &#123; Pane root = new Pane(); root.setPrefSize(1000,400); return root; &#125;&#125; 二、新建Tower塔类，模拟矩形塔 类名定义为Tower, 属性有哪些？ 如果是绘制图形，则需要坐标位置信息，据此在构造方法中传入坐标值 Tower类中需要绘制一个矩形，这个矩形可称为塔, 在它的边上需要绘制多个圆圈，从小到大顺序 Tower类须继承 StackPane，因为同一个位置的其它圆的绘制有先后顺序 1234567891011121314//Tower是一个StackPaneprivate class Tower extends StackPane &#123; Tower(int x, int y) &#123; //当前Tower的坐标 setTranslateX(x); setTranslateY(y); //当前Tower容器的大小 setPrefSize(400,400); //定义一个矩形 Rectangle rectTower = new Rectangle(35,35); //将这个矩形添加到当前的Tower容器中 getChildren().add(rectTower); &#125;&#125; ​ 三、创建三个Tower对象 此步骤创建三个Tower对象，并添加到容器中，同时设定到Scene场景对象中 1234567891011121314151617181920public class TowerHanoi extends Application &#123; @Override public void start(Stage stage) throws Exception &#123; stage.setScene(new Scene(createContent())); stage.show(); &#125; private Parent createContent() &#123; Pane root = new Pane(); root.setPrefSize(1000,400); for (int i = 0; i &lt; 3; i++) &#123; //纵坐标不变, 横坐标每根据循环变量 i 变化 Tower tower = new Tower(i*400, 0); //将三个Tower对象添加到root面板容器中 root.getChildren().add(tower); &#125; return root; &#125;&#125; 四、在第一个Tower中绘制N个圆 绘制的圆表示放在Tower上的圆盘, 此处我们使用一个常量 NUM_CIRCLES 表示, 设定为4, 也可随意设置 1private static final int NUM_CIRCLES = 4; 在创建第一个Tower时，将NUM_CIRCLES个圆盘绘制在 Tower上面 绘制时使用Circle类创建圆 循环时从最大的开始，在计算半径时保证最大的圆盘先添加到Tower面板容器中，最后绘制的在Tower面板容器的最上面, 使用的是栈结构 12345678910111213141516171819202122232425262728293031323334public class TowerHanoi extends Application &#123; @Override public void start(Stage stage) throws Exception &#123; stage.setScene(new Scene(createContent())); stage.show(); &#125; private Parent createContent() &#123; Pane root = new Pane(); root.setPrefSize(1000,400); for (int i = 0; i &lt; 3; i++) &#123; //纵坐标不变, 横坐标每根据循环变量 i 变化 Tower tower = new Tower(i*400, 0); //i=0的时候，画三个圆盘 if(i==0) &#123; //循环时从最大的开始 for (int j = NUM_CIRCLES; j &gt; 0; j--) &#123; Circle circle = new Circle(30+j*20, null); //设置边线颜色和宽度 circle.setStroke(Color.BLUE); circle.setStrokeWidth(circle.getRadius()/20); //添加到面板容器 tower.addCircle(circle); &#125; &#125; //将三个Tower对象添加到root面板容器中 root.getChildren().add(tower); &#125; return root; &#125;&#125; 五、获取Tower塔上半径最小的圆盘 在Tower类中定义一个方法，用于获取Tower面板容器中最上面的那个圆盘 这个方法采用getChildren()获取当前Tower 面板容器对象上的所有元素, 转换成stream, 再通过filter和map以及min这些中间操作后获得半径最小的圆盘 stream 是java8之后的重要特性，此处还用到 lambda 表达式, 在集合的内部迭代中经常使用 123456789private Circle getTop() &#123; var top = getChildren() .stream() .filter(element-&gt;element instanceof Circle) //返回元素类型为Circle的stream .map(element-&gt;(Circle)element) //将过滤后的类型转换为Circle类型 .min(Comparator.comparingDouble(Circle::getRadius)) //比较一下所有的Circle，并得到半径最小的那个圆盘 .orElse(null); return top;&#125; 六、定义方法添加圆盘到Tower塔 面板容器中123456789101112131415void addCircle(Circle circle) &#123; //获取画在StackPane也就是Tower上最上面的那个Circle Circle topMost = getTop(); //如果为null则表示Tower上面没有圆 if(topMost==null) &#123; getChildren().add(circle); &#125; else &#123; //如果不为空，则添加到Tower上的圆要和最上层的圆进行比较，小于最小层时才能添加 if(circle.getRadius() &lt; topMost.getRadius()) &#123; getChildren().add(circle); &#125; &#125; //getChildren().add(circle);&#125; 七、点击Tower时获得最小半径的圆盘并改变颜色 定义一个Optional, 用于解决可能出现的NullPointException 变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回 Optional.empty()方法是一个静态工厂方法，它返回Optional类的特定单一实例 1private Optional&lt;Circle&gt; selectedCircle = Optional.empty(); 为Tower上的矩形定义一个鼠标点击事件，使用setOnMouseClicked Optional类提供了一个isPresent方法，如果Optional对象包含值，该方法就返回true, 如果不包含则返回false addCircle方法是在Tower类中定义的，目的是将圆添加到Tower中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Tower是一个StackPaneprivate class Tower extends StackPane &#123; Tower(int x, int y) &#123; //当前Tower的坐标 setTranslateX(x); setTranslateY(y); //当前Tower容器的大小 setPrefSize(400,400); //定义一个矩形 Rectangle rectTower = new Rectangle(35,35); //监听每一个矩形塔的点击事件 rectTower.setOnMouseClicked(e-&gt;&#123; //判断Optional对象是否包含值,如果包含则返回true,否则返回false if(selectedCircle.isPresent()) &#123; //包含值则获取其中的对象 Circle c = selectedCircle.get(); //设置边框颜色 c.setStroke(Color.BLUE); //添加圆盘到当前Tower中 addCircle(c); //模拟一个空的Optional对象,重新赋值 selectedCircle = Optional.empty(); &#125; else &#123; selectedCircle = Optional.ofNullable(getTop()); //如果选中了则将边框颜色设置为红色 selectedCircle.get().setStroke(Color.RED); &#125; &#125;); //将这个矩形添加到当前的Tower容器中 getChildren().add(rectTower); &#125; private Circle getTop() &#123; var top = getChildren() .stream() .filter(element-&gt;element instanceof Circle) //返回元素类型为Circle的stream .map(element-&gt;(Circle)element) //将过滤后的类型转换为Circle类型 .min(Comparator.comparingDouble(Circle::getRadius)) //比较一下所有的Circle，并得到半径最小的那个圆盘 .orElse(null); return top; &#125; private void addCircle(Circle circle) &#123; &#125;&#125; 八、addCircle方法实现 addCircle方法是将选中的Circle添加到不同的Tower上面 12345678910111213141516private void addCircle(Circle circle) &#123; //获取画在StackPane也就是Tower上最小的Circle Circle topCircle = getTop(); //如果为null则表示Tower上面没有圆， 没有圆盘则可将圆盘直接添加到Tower上 if(topCircle==null) &#123; getChildren().add(circle); &#125; else &#123; //如果Tower上有圆盘，则添加到Tower上的圆盘要和最上层的圆盘进行比较，小于最上面那个圆盘时才能添加 if(circle.getRadius() &lt; topCircle.getRadius()) &#123; getChildren().add(circle); &#125; &#125;&#125; 九、完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package top.codecool.game;import javafx.application.Application;import javafx.scene.Parent;import javafx.scene.Scene;import javafx.scene.layout.Pane;import javafx.scene.layout.StackPane;import javafx.scene.paint.Color;import javafx.scene.shape.Circle;import javafx.scene.shape.Rectangle;import javafx.stage.Stage;import java.util.Comparator;import java.util.Optional;public class TowerHanoiApp extends Application &#123; private static final int NUM_CIRCLES = 4; private Optional&lt;Circle&gt; selectedCircle = Optional.empty(); @Override public void start(Stage stage) throws Exception &#123; stage.setScene(new Scene(createContent())); stage.setTitle(&quot;汉诺塔游戏&quot;); stage.show(); &#125; private Parent createContent() &#123; Pane root = new Pane(); root.setPrefSize(400*3,400); for (int i = 0; i &lt; 3; i++) &#123; Tower tower = new Tower(i*400, 0); if(i==0) &#123; for (int j = NUM_CIRCLES; j &gt; 0; j--) &#123; Circle circle = new Circle(30+j*20, null); circle.setStroke(Color.BLUE); circle.setStrokeWidth(circle.getRadius()/20); tower.addCircle(circle); &#125; &#125; root.getChildren().add(tower); &#125; return root; &#125; private class Tower extends StackPane &#123; Tower(int x, int y) &#123; setTranslateX(x); setTranslateY(y); setPrefSize(400,400); Rectangle rectTower = new Rectangle(35,35); rectTower.setOnMouseClicked(e-&gt;&#123; if(selectedCircle.isPresent()) &#123; Circle c = selectedCircle.get(); c.setStroke(Color.BLUE); addCircle(c); selectedCircle = Optional.empty(); &#125; else &#123; selectedCircle = Optional.ofNullable(getTop()); selectedCircle.get().setStroke(Color.RED); &#125; &#125;); getChildren().add(rectTower); &#125; private Circle getTop() &#123; var top = getChildren() .stream() .filter(n-&gt;n instanceof Circle) .map(n-&gt;(Circle)n) .min(Comparator.comparingDouble(Circle::getRadius)) .orElse(null); return top; &#125; private void addCircle(Circle circle) &#123; Circle topCircle = getTop(); if(topCircle==null) &#123; getChildren().add(circle); &#125; else &#123; if(circle.getRadius() &lt; topCircle.getRadius()) &#123; getChildren().add(circle); &#125; &#125; &#125; &#125;&#125; 总结本文使用JavaFX和Java8中的stream、Optional、Lambda表达式等技术实现了一个简易版的汉诺塔小游戏，借此练习如何使用这些新特性，提升技能水平。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"(十) JavaScript-Canvas 雪花飘(2)","slug":"JavaScript/(10)-JavaScript-Canvas雪花飘(2)","date":"2022-07-30T01:05:00.000Z","updated":"2022-07-30T02:23:05.532Z","comments":true,"path":"2022/07/30/JavaScript/(10)-JavaScript-Canvas雪花飘(2)/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/30/JavaScript/(10)-JavaScript-Canvas%E9%9B%AA%E8%8A%B1%E9%A3%98(2)/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 旋转的图形 (十) JavaScript-Canvas 雪花飘(2) 在(九) JavaScript-Canvas 雪花飘 中利用两个Canvas绘制了一个图形并在中心旋转，本篇中加入面向对象内容，创建多个图形并旋转，让每个图形旋转的同时向上或向下移动 1.参考 (九) JavaScript-Canvas 雪花飘 这篇完成的代码 先设计两个canvas, 定义他们的样式, 两个canvas都设置为绝对布局,通过z-index设置显示位置 隐藏第一个canvas, display:none canvas1.width = 200 , canvas1.height= 200 表示第一个canvas的宽和高，做成图形后，就是整个图形的大小, 可设计成动态随机大小 第二个画布canvas2的宽度和高度设计为窗口的度和高 let color = ‘hsl(‘+Math.random()*100+’,50%,50%)’ 定义一个全局的随机颜色变量,使用hsl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;雪花飘&lt;/title&gt; &lt;style&gt; #canvas1 &#123; position:absolute; top: 0; left: 0; background-color: rgb(11, 4, 4); z-index: 11; display:none; &#125; #canvas2 &#123; position:absolute; top: 0; left: 0; background: rgb(11, 4, 4); z-index: -11; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas1&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas2&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas1 = document.getElementById(&#x27;canvas1&#x27;) const ctx1 = canvas1.getContext(&#x27;2d&#x27;) canvas1.width = 200 canvas1.height= 200 //画布设置 ctx1.lineCap = &#x27;round&#x27;; //阴影设置 ctx1.shadowColor = &#x27;rgba(0,0,0,0.7)&#x27;; ctx1.shadowOffsetX = 10; ctx1.shadowOffsetY = 5; ctx1.shadowBlur = 10; //第二个画布 const canvas2 = document.getElementById(&#x27;canvas2&#x27;); const ctx2 = canvas2.getContext(&#x27;2d&#x27;); canvas2.width = window.innerWidth; canvas2.height = window.innerHeight; let color = &#x27;hsl(&#x27;+Math.random()*100+&#x27;,50%,50%)&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 定义两个函数用于画线和画图形(由线组成) drawLine为画线函数，线长固定为100(从坐标0,0到100,0) 线的颜色设置为定义的全局color 12345678910111213141516171819function drawLine() &#123; ctx1.beginPath() ctx1.moveTo(0,0) ctx1.lineTo(100, 0) ctx1.lineWidth=4 ctx1.strokeStyle = color ctx1.stroke()&#125;function draw() &#123; ctx1.save() ctx1.translate(canvas1.width/2, canvas1.height/2); for (let i = 0; i &lt; 12; i++)&#123; //线条数量 ctx1.rotate((Math.PI * 2)/12);//旋转度数 2PI 除以 线条数量 drawLine();//调用画线 &#125; ctx1.restore()&#125;//调用绘图函数draw() 接下来将canvas1的图形转换为image，使用image的toDataURL()方法 12const image = new Image()image.src = canvas1.toDataURL(); 注册image的加载事件,图形加载完成会触发这个事件 1234//也可以使用addEventListener方式注册事件image.onload = function() &#123;&#125; 3. 定义一个Snow形状类 定义Snow的目的是为了创建多个对象 构造函数的定义，属性的定义， 需要搞清楚有哪些属性 属性需要 image 图形；width,height 图形的宽度和高度；x,y图形的坐标; angle旋转的角度；旋转的速度speed等等 123456789101112131415161718192021222324class Snow &#123; //在调用时传入的是第个canvas的宽度和高度 constructor(canvasWidth, canvasHeight, image)&#123; this.canvasWidth = canvasWidth this.canvasHeight = canvasHeight this.image = image //随机一个size值 this.size = Math.random() * 0.4 + 0.1 //定义图形的宽度和高度 this.width = this.image.width * this.size this.height = this.image.height * this.size //图形的x,y坐标必须在画布canvas的宽高范围以内 this.x = Math.random() * this.canvasWidth this.y = Math.random() * this.canvasHeight //定义一个速度属性，每个Snow对象的速度都是随机值 this.speed = Math.random() * 1 + 1; //角度初始值为0 this.angle = 0; //角度的变化值 this.va = Math.random() * 0.05 - 0.025; &#125;&#125; 4. 在Snow类中定义draw和update函数，用于绘图和更新属性 update函数主要用于对象属性的重新设置或更改，比如坐标不断更改 draw函数用于将图形绘制到画布上， 使用drawImage函数时，图形的位置是当前图形对象的宽高分别除以2，让它以图形的中心点旋转 画图的时候要用上save和restore方法，避免影响到其它Snow对象 1234567891011121314151617181920212223242526class Snow &#123; //.....省略了构造函数 update()&#123; //角度重新赋值 this.angle += this.va; //判断图形的纵坐标是否超出画布的高度，如果超出高度则重新设置坐标 if (this.y &lt; -this.height) &#123; this.y = this.canvasHeight + this.height; this.x = Math.random() * (this.canvasWidth - this.width); this.angle = 0; &#125; else &#123; //未超出高度则让y的值不断减小，speed的值越大，向上移动的速度越快 this.y -= this.speed; &#125; &#125; //画图 draw(ctx)&#123; ctx.save(); ctx.translate(this.x, this.y ); ctx.rotate(this.angle); ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height) ctx.restore(); &#125;&#125; 5. 实现动画函数 创建数组snows，存储多个Snow对象 一定要在图形加载完成后再创建snow对象 123456789101112131415161718let snows=[]image.onload = function()&#123; for (let i = 0; i &lt; 50; i++)&#123; snows.push(new Snow(canvas2.width, canvas2.height, image)) &#125; function animate() &#123; //每次清除画布 ctx2.clearRect(0,0,canvas2.width, canvas2.height) //遍历数组,调用每个对象的draw和update方法 for(let i=0;i&lt;snows.length;i++) &#123; snows[i].draw(ctx2) snows[i].update() &#125; window.requestAnimationFrame(animate) &#125; animate()&#125; 6. 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas1 &#123; position:absolute; top: 0; left: 0; background-color: rgb(11, 4, 4); z-index: 11; display: none; &#125; #canvas2 &#123; position:absolute; top: 0; left: 0; background: rgb(11, 4, 4); z-index: -11; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas1&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas2&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas1 = document.getElementById(&#x27;canvas1&#x27;) const ctx1 = canvas1.getContext(&#x27;2d&#x27;) canvas1.width = 200 canvas1.height= 200 //画布设置 ctx1.lineCap = &#x27;round&#x27;; //阴影设置 ctx1.shadowColor = &#x27;rgba(0,0,0,0.7)&#x27;; ctx1.shadowOffsetX = 10; ctx1.shadowOffsetY = 5; ctx1.shadowBlur = 10; //第二个画布 const canvas2 = document.getElementById(&#x27;canvas2&#x27;); const ctx2 = canvas2.getContext(&#x27;2d&#x27;); canvas2.width = window.innerWidth; canvas2.height = window.innerHeight; let color = &#x27;hsl(&#x27;+Math.random()*100+&#x27;,50%,50%)&#x27; function drawLine() &#123; ctx1.beginPath() ctx1.moveTo(0,0) ctx1.lineTo(100, 0) ctx1.lineWidth=4 ctx1.strokeStyle = color ctx1.stroke() &#125; function draw() &#123; ctx1.save() ctx1.translate(canvas1.width/2, canvas1.height/2); for (let i = 0; i &lt; 12; i++)&#123; ctx1.rotate((Math.PI * 2)/12); drawLine(); &#125; ctx1.restore() &#125; draw() const image = new Image() image.src = canvas1.toDataURL(); class Snow &#123; constructor(canvasWidth, canvasHeight, image)&#123; this.canvasWidth = canvasWidth this.canvasHeight = canvasHeight this.image = image this.size = Math.random() * 0.4 + 0.1 this.width = this.image.width * this.size this.height = this.image.height * this.size this.x = Math.random() * this.canvasWidth this.y = Math.random() * this.canvasHeight this.speed = Math.random() * 1 + 1; this.angle = 0; this.va = Math.random() * 0.05 - 0.025; &#125; update()&#123; this.angle += this.va; if (this.y &lt; -this.height) &#123; this.y = this.canvasHeight + this.height; this.x = Math.random() * (this.canvasWidth - this.width); this.angle = 1; &#125; else this.y -= this.speed; &#125; draw(ctx)&#123; ctx.save() ctx.translate(this.x, this.y) ctx.rotate(this.angle) ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height) ctx.restore(); &#125; &#125; let snows = [] image.onload = function()&#123; for (let i = 0; i &lt; 50; i++)&#123; snows.push(new Snow(canvas2.width, canvas2.height, image)) &#125; function animate() &#123; ctx2.clearRect(0,0,canvas2.width, canvas2.height) for(let i=0;i&lt;snows.length;i++) &#123; snows[i].draw(ctx2) snows[i].update() &#125; window.requestAnimationFrame(animate) &#125; animate() &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(九) JavaScript-Canvas 雪花飘","slug":"JavaScript/(9)-JavaScript-Canvas雪花飘","date":"2022-07-26T11:05:00.000Z","updated":"2022-07-29T13:53:32.420Z","comments":true,"path":"2022/07/26/JavaScript/(9)-JavaScript-Canvas雪花飘/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/26/JavaScript/(9)-JavaScript-Canvas%E9%9B%AA%E8%8A%B1%E9%A3%98/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 旋转的图片 (九) JavaScript-Canvas 雪花飘 上一篇中让图片转了起来， 本篇自己设计一张图形，然后让图形转动； 在网页代码中要注意，设计了两个Canvas，两个Canvas的位置在CSS中有具体的描述。其中第一个画布准备画一个图形，然后再将图形整体画到第二个画布上 1. 设计网页代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas1 &#123; position:absolute; top: 0; left: 0; background-color: rgb(11, 4, 4); z-index: 11; &#125; #canvas2 &#123; position:absolute; top: 0; left: 0; background: rgb(11, 4, 4); z-index: -11; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas1&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas2&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ //第一个画布 const canvas1 = document.getElementById(&#x27;canvas1&#x27;) const ctx1 = canvas1.getContext(&#x27;2d&#x27;) canvas1.width = 200 canvas1.height= 200 //画布设置 ctx1.lineCap = &#x27;round&#x27;; //阴影设置 ctx1.shadowColor = &#x27;rgba(0,0,0,0.7)&#x27;; ctx1.shadowOffsetX = 10; ctx1.shadowOffsetY = 5; ctx1.shadowBlur = 10; //第二个画布 const canvas2 = document.getElementById(&#x27;canvas2&#x27;); const ctx2 = canvas2.getContext(&#x27;2d&#x27;); canvas2.width = window.innerWidth; canvas2.height = window.innerHeight; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1. 先画几根线 定义一个画线函数 设定线从坐标(0,0) 开始，线长100, 线宽4, 颜色orange 12345678function drawLine() &#123; ctx1.beginPath() ctx1.moveTo(0, 0) ctx1.lineTo(100, 0) ctx1.lineWidth=4 ctx1.strokeStyle=&#x27;orange&#x27; ctx1.stroke()&#125; 2. 定义一个draw函数，绕中心点画多根线12345678910111213141516171819202122232425function drawLine() &#123; ctx1.beginPath() ctx1.moveTo(0, 0) ctx1.lineTo(100, 0) ctx1.lineWidth=4 ctx1.strokeStyle=&#x27;orange&#x27; ctx1.stroke()&#125;function draw() &#123; //注意save方法 ctx1.save() //将原点平移到中心位置 ctx1.translate( canvas1.width/2, canvas1.height/2); for (let i = 0; i &lt; 12; i++)&#123; //线条数量 //旋转 ctx1.rotate((Math.PI * 2)/12);//旋转度数 2PI 除以 线条数目 drawLine();//画线 &#125; //恢复状态 ctx1.restore()&#125;draw() //调用绘图函数 绘图结果 3. 将绘制在Canvas1上面的图形转换为图片12const image = new Image()image.src = canvas1.toDataURL(); 4. 图片旋转 注意一定要注册一个事件，图片加载完成后才能进入动画 123456789101112131415161718image.onload = function()&#123; let angle = 1 function animate() &#123; //先清空，再平移 ctx2.clearRect(0,0,canvas2.width, canvas2.height) ctx2.save() //将图片移到canvas2的中心位置 ctx2.translate(canvas2.width/2-100, canvas2.height/2-100) //旋转角度 ctx2.rotate(angle * Math.PI/360) //画图 ctx2.drawImage(image, 0-100, 0-100, 200, 200) ctx2.restore(); angle += 4 //更新角度 window.requestAnimationFrame(animate) &#125; animate()&#125; 5. 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas1 &#123; position:absolute; top: 0; left: 0; background-color: rgb(11, 4, 4); z-index: 11; &#125; #canvas2 &#123; position:absolute; top: 0; left: 0; background: rgb(11, 4, 4); z-index: -11; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas1&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas2&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas1 = document.getElementById(&#x27;canvas1&#x27;) const ctx1 = canvas1.getContext(&#x27;2d&#x27;) canvas1.width = 200 canvas1.height= 200 //画布设置 ctx1.lineCap = &#x27;round&#x27;; //阴影设置 ctx1.shadowColor = &#x27;rgba(0,0,0,0.7)&#x27;; ctx1.shadowOffsetX = 10; ctx1.shadowOffsetY = 5; ctx1.shadowBlur = 10; //第二个画布 const canvas2 = document.getElementById(&#x27;canvas2&#x27;); const ctx2 = canvas2.getContext(&#x27;2d&#x27;); canvas2.width = window.innerWidth; canvas2.height = window.innerHeight; function drawLine() &#123; ctx1.beginPath() ctx1.moveTo(0,0) ctx1.lineTo(100, 0) ctx1.lineWidth=4 ctx1.strokeStyle=&#x27;orange&#x27; ctx1.stroke() &#125; function draw() &#123; ctx1.save() ctx1.translate( canvas1.width/2, canvas1.height/2); for (let i = 0; i &lt; 12; i++)&#123; ctx1.rotate((Math.PI * 2)/12); drawLine(); &#125; ctx1.restore() &#125; draw() const image = new Image() image.src = canvas1.toDataURL(); image.onload = function()&#123; let angle = 1 function animate() &#123; ctx2.clearRect(0,0,canvas2.width, canvas2.height) ctx2.save() ctx2.translate(canvas2.width/2-100, canvas2.height/2-100) ctx2.rotate(angle * Math.PI/360) ctx2.drawImage(image, 0-100, 0-100, 200, 200) ctx2.restore(); angle+=4 window.requestAnimationFrame(animate) &#125; animate() &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多一些图形旋转，每个图形的大小可自由设置，垂直飘落, 后面章节再完善","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(八) JavaScript-Canvas旋转的图片","slug":"JavaScript/(8)-JavaScript-Canvas旋转的图片","date":"2022-07-25T01:05:00.000Z","updated":"2022-07-29T14:22:01.591Z","comments":true,"path":"2022/07/25/JavaScript/(8)-JavaScript-Canvas旋转的图片/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/25/JavaScript/(8)-JavaScript-Canvas%E6%97%8B%E8%BD%AC%E7%9A%84%E5%9B%BE%E7%89%87/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 旋转的图片 (八) JavaScript-Canvas旋转的图片 使用 Image类型创建图片对象, 自定义类 Picture 1. 设计网页代码123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;旋转的图片&lt;/title&gt; &lt;style&gt; canvas &#123; position: absolute; background: black; width: 100%; height: 100%; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //创建图片对象 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 创建一个Image对象 使用 Image 创建一个对象，设置对象的src属性，表示图片的路径，此处将图片和页面放置在同一目录下，所以只需图片名称 123//创建图片对象const cherry = new Image()cherry.src = &#x27;cherry.png&#x27; 3. 在Canvas Context上 画图 图片是异步加载所以需要监听图片加载事件load, 加载完成后才能将图片画到Canvas上 使用translate平移坐标到(100,100), 为了清楚的了解后续图片的旋转 使用rotate 旋转 canvas 0度，也就是不旋转 再增加一个填充矩形，清楚图片位置，无其它作用 drawImage 画图，第1个参数为图片对象，第2，3个参数表示图片的坐标，第4，5个参数表示图片宽和高 12345678cherry.addEventListener(&#x27;load&#x27;, function()&#123; ctx.translate(100,100) ctx.rotate(0 * Math.PI/360) ctx.fillStyle= &#x27;black&#x27; ctx.fillRect(0,0,500,500) ctx.drawImage(cherry, 0, 0, 80, 80)&#125;) 效果如图 4. 再画一个位置不同的图 图片的位置还是平移100，但此时会发现，平移是相对于上面的图片位置 12345678910111213cherry.addEventListener(&#x27;load&#x27;, function()&#123; ctx.translate(100,100) ctx.rotate(0 * Math.PI/360) ctx.fillStyle= &#x27;black&#x27; ctx.fillRect(0,0,500,500) ctx.drawImage(cherry, 0, 0, 80, 80) ctx.translate(100,100) ctx.rotate(0 * Math.PI/360) ctx.fillStyle= &#x27;orange&#x27; ctx.fillRect(0,0,500,500) ctx.drawImage(cherry, 0, 0, 80, 80)&#125;) 效果如图 5. 使用save和restore方法 使用这两个方法后，恢复之前的状态，其实就是将save()之后的绘图操作入栈，调用restore()后出栈，也就是恢复到当前绘图之前的状态，后续画图会使用save()之前的状态 123456789101112131415cherry.addEventListener(&#x27;load&#x27;, function()&#123; ctx.save() ctx.translate(100,100) ctx.rotate(0 * Math.PI/360) ctx.fillStyle= &#x27;black&#x27; ctx.fillRect(0,0,500,500) ctx.drawImage(cherry, 0, 0, 80, 80) ctx.restore() ctx.translate(100,100) ctx.rotate(30 * Math.PI/360) ctx.fillStyle= &#x27;orange&#x27; ctx.fillRect(0,0,500,500) ctx.drawImage(cherry, 0, 0, 80, 80)&#125;) 效果如图: 桔色背景的图片旋转了30度，平移的位置相对于最开始时的状态; 如果桔色背景下方还要画图，也可以加上save和restore，使得桔色图形的属性设置不会影响后续图形 6. 让图片旋转起来 将绘图代码封装成函数，然后利用window.requestAnimationFrame函数让图片旋转起来 1234567891011121314151617181920212223242526272829303132333435363738394041const cherry = new Image()cherry.src = &#x27;cherry.png&#x27;let angle1 = 1 //第一张图片的旋转角度let angle2 = 10 //第二张图片折旋转角度function draw() &#123; //第一张图片 ctx.save() ctx.translate(canvas.width/2,canvas.height/2) ctx.rotate(angle1 * Math.PI/360) ctx.fillStyle= &#x27;black&#x27; ctx.fillRect(0,0,300,300) ctx.drawImage(cherry, 0, 0, 80, 80) ctx.restore() //第二张图片 ctx.save() ctx.translate(canvas.width/2,canvas.height/2) ctx.rotate(angle2 * Math.PI/360) ctx.fillStyle= &#x27;orange&#x27; ctx.fillRect(0,0,300,300) ctx.drawImage(cherry, 0, 0, 80, 80) ctx.restore()&#125;//图片加载完成后调用draw方法cherry.addEventListener(&#x27;load&#x27;, function()&#123; draw()&#125;) //动画函数 animate, 不断地调用画图函数，同时更改两个角度值function animate() &#123; ctx.clearRect(0,0,canvas.width, canvas.height) draw() angle1+=1 angle2+=10 window.requestAnimationFrame(animate)&#125;animate() 效果如图， 也可以去掉矩形填充 7. 旋转的中心点改成图片中心 在画图时改变一下图片的起始绘制坐标 1234567891011121314151617181920212223242526272829303132333435let angle1 = 1let angle2 = 10function draw() &#123; ctx.save() ctx.translate(canvas.width/2,canvas.height/2) ctx.rotate(angle1 * Math.PI/360) ctx.fillStyle= &#x27;black&#x27; ctx.fillRect(0,0,300,300) //更改画图片时的起始坐标 ctx.drawImage(cherry, 0-80/2, 0-80/2, 80, 80) ctx.restore() ctx.save() ctx.translate(canvas.width/2,canvas.height/2) ctx.rotate(angle2 * Math.PI/360) ctx.fillStyle= &#x27;orange&#x27; ctx.fillRect(0,0,300,300) //更改画图片时的起始坐标 ctx.drawImage(cherry, 0-80/2, 0-80/2, 80, 80) ctx.restore()&#125;cherry.addEventListener(&#x27;load&#x27;, function()&#123; draw()&#125;) function animate() &#123; ctx.clearRect(0,0,canvas.width, canvas.height) draw() angle1+=1 angle2+=10 window.requestAnimationFrame(animate)&#125;animate() 效果如图， 尝试去掉填充矩形 再用save() 和 restore() 函数 ，尝试使用面向对象的方法绘图","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(七) JavaScript-Canvas-滑动星座","slug":"JavaScript/(7)-JavaScript-Canvas滑动星座","date":"2022-07-22T10:00:00.000Z","updated":"2022-07-24T04:14:07.171Z","comments":true,"path":"2022/07/22/JavaScript/(7)-JavaScript-Canvas滑动星座/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/22/JavaScript/(7)-JavaScript-Canvas%E6%BB%91%E5%8A%A8%E6%98%9F%E5%BA%A7/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 最终效果图 (七) JavaScript-Canvas-滑动星座 在上节的基础上增加了事件处理，使用addEventListener() 函数，数组元素的添加与删除在示例中也有应用 1. 设计网页代码 创建一个数组存储所有Circle对象 创建一个色相变量，用于每个圆的颜色设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; overflow: hidden; &#125; #canvas &#123; position: absolute; border: 2px solid black; background-color: black; top: 0; left: 0; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //定义一个数组，存储Circle对象 let circleArray = [] //定义色相变量，用于颜色变化 let hue = 0; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. Canvas事件 使用addEventListener添加一个点击(click)事件 点击时将位置信息存储在mouse对象中 点击时创建多个Circle对象，存储在数组中 还可以注册一个鼠标移动(mousemove)事件，让鼠标移动时也产生多个Circle对象 12345678910111213141516171819202122232425//鼠标点击时的位置记录const mouse = &#123; x : undefined, y : undefined&#125;//鼠标点击时将点击位置赋值给mouse对象,记录鼠标点击的位置canvas.addEventListener(&#x27;click&#x27;, function(e)&#123; mouse.x = e.x mouse.y = e.y //创建10个圆存储在数组中 for (let i = 0; i &lt; 10; i++) &#123; circleArray.push(new Circle()) &#125;&#125;)canvas.addEventListener(&#x27;mousemove&#x27;, function(e)&#123; mouse.x = e.x mouse.y = e.y for (let i = 0; i &lt; 5; i++) &#123; circleArray.push(new Circle()) &#125;&#125;) 3. 定义圆类 定义一个圆类，几个属性都在构造方法中初始化 圆的中心位置在点击的时候确定 圆的大小随机设置 圆的速度使用speedX 和speedY, 这两个值自己随意设置 颜色使用上面定义的hue设置，hue在动画函数中去更新 update函数用于更新当前圆对象的x和y坐标值, 判断圆的大小，如果大于0.2则不断的减小, 达成一种不断缩小的效果 draw函数用于画一个填充颜色的圆 123456789101112131415161718192021222324252627class Circle &#123; //初始化属性 constructor() &#123; this.x = mouse.x this.y = mouse.y //随机数 定义在一个范围 this.size = Math.random() * 15 + 1 //速度 定义在-1.5到1.5之间, 可随意设置 this.speedX = Math.random() * 3 - 1.5 this.speedY = Math.random() * 3 - 1.5 this.color = &#x27;hsl(&#x27;+hue+&#x27;,100%,50%)&#x27; &#125; update() &#123; this.x += this.speedX this.y += this.speedY if(this.size &gt; 0.2) &#123; this.size -= 0.1 &#125; &#125; draw() &#123; ctx.fillStyle = this.color ctx.beginPath() ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2) ctx.fill() &#125;&#125; 4. 动画函数实现 实现方式和之前的类似 注意每次都需要调用clearRect方法 在圆不断变小时，小到一定数值时让圆消失，做法是直接从数组中删除 123456789101112131415161718192021222324252627282930313233343536function animate() &#123; ctx.clearRect(0,0,canvas.width, canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; circleArray[i].update()//更新 circleArray[i].draw()//绘制 for (let j = i; j &lt; circleArray.length; j++) &#123; //计算当前圆和其它圆之间的距离 const newX = circleArray[i].x - circleArray[j].x const newY = circleArray[i].y - circleArray[j].y const distance = Math.sqrt(newX*newX + newY*newY) //画线 if(distance &lt; 100) &#123; ctx.beginPath() ctx.strokeStyle = circleArray[i].color ctx.lineWidth = 1 ctx.moveTo(circleArray[i].x, circleArray[i].y) ctx.lineTo(circleArray[j].x, circleArray[j].y) ctx.stroke() ctx.closePath() &#125; &#125; //如果当前圆的尺寸较小，则从数组中删除当前Circle对象 if(circleArray[i].size &lt;= 0.3 ) &#123; //删除元素 circleArray.splice(i,1) i-- &#125; &#125; hue+=0.5 //改变色相值 requestAnimationFrame(animate)&#125;animate() 5. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; overflow: hidden; &#125; #canvas &#123; position: absolute; border: 2px solid black; background-color: black; top: 0; left: 0; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) let circleArray = [] let hue = 0; canvas.width = window.innerWidth canvas.height = window.innerHeight const mouse = &#123; x : undefined, y : undefined &#125; canvas.addEventListener(&#x27;click&#x27;, function(e)&#123; mouse.x = e.x mouse.y = e.y for (let i = 0; i &lt; 10; i++) &#123; circleArray.push(new Circle()) &#125; &#125;) canvas.addEventListener(&#x27;mousemove&#x27;, function(e)&#123; mouse.x = e.x mouse.y = e.y for (let i = 0; i &lt; 5; i++) &#123; circleArray.push(new Circle()) &#125; &#125;) class Circle &#123; //初始化属性 constructor() &#123; this.x = mouse.x this.y = mouse.y this.size = Math.random() * 15 + 1 this.speedX = Math.random() * 3 - 1.5 this.speedY = Math.random() * 3 - 1.5 this.color = &#x27;hsl(&#x27;+hue+&#x27;,100%,50%)&#x27; &#125; update() &#123; this.x += this.speedX this.y += this.speedY if(this.size &gt; 0.2) &#123; this.size -= 0.1 &#125; &#125; draw() &#123; ctx.fillStyle = this.color //ctx.fillStyle = &#x27;white&#x27; ctx.beginPath() ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2) ctx.fill() &#125; &#125; function animate() &#123; ctx.clearRect(0,0,canvas.width, canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; circleArray[i].update() circleArray[i].draw() for (let j = i; j &lt; circleArray.length; j++) &#123; const dx = circleArray[i].x - circleArray[j].x const dy = circleArray[i].y - circleArray[j].y const distance = Math.sqrt(dx*dx + dy*dy) //画线 if(distance &lt; 100) &#123; ctx.beginPath() ctx.strokeStyle = circleArray[i].color ctx.lineWidth = 1 ctx.moveTo(circleArray[i].x, circleArray[i].y) ctx.lineTo(circleArray[j].x, circleArray[j].y) ctx.stroke() ctx.closePath() &#125; &#125; if(circleArray[i].size &lt;= 0.3 ) &#123; //删除元素 circleArray.splice(i,1) i-- &#125; &#125; hue+=0.5 requestAnimationFrame(animate) &#125; animate() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中使用了事件，数组元素的添加和删除，学到了就能在开发中能灵活使用","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(六) JavaScript-Canvas-星座","slug":"JavaScript/(6)-JavaScript-Canvas星座","date":"2022-07-22T00:00:00.000Z","updated":"2022-07-23T01:16:50.527Z","comments":true,"path":"2022/07/22/JavaScript/(6)-JavaScript-Canvas星座/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/22/JavaScript/(6)-JavaScript-Canvas%E6%98%9F%E5%BA%A7/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 最终效果图 (六) JavaScript-Canvas-星座 在 (五) JavaScript-Canvas球球乱撞的基础上增加一些小小的特效，简单的平面几何的应用-勾股定理，两个点之间画一条线 1. 上一篇 的最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius //增加一个颜色属性 this.color = &#x27;hsla(&#x27;+(Math.random()*360)+&#x27;, 100%, 50%, 0.6)&#x27; &#125; //画一个圆 draw() &#123; ctx.beginPath() //设置填充颜色 ctx.fillStyle = this.color ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 //ctx.strokeStyle = &#x27;blue&#x27; //ctx.stroke() //填充 ctx.fill() &#125; //更新圆的位置 update() &#123; //判断圆是否超出canvas边界，判断时需要将半径也算上 if(this.x + this.radius &gt; canvas.width || this.x-this.radius &lt; 0)&#123; //如果超出x轴左右两边的边界则重新设置 dx的值 this.dx = -this.dx &#125; //高度边界判断 if(this.y+this.radius &gt; canvas.height || this.y-this.radius &lt; 0) &#123; this.dy = -this.dy &#125; //更改x和y坐标 this.x += this.dx this.y += this.dy //调用draw()函数重新画圆 this.draw() &#125; &#125; //*************************************************************** //声明一个数组 var circleArray = [] //循环50次，产生50个Circle对象 for (let i = 0; i &lt; 50; i++) &#123; //自动生成x,y坐标,范围必须在Canvas画布内 let x = Math.random() * (canvas.width-radius*2) + radius let y = Math.random() * (canvas.height-radius*2) + radius //速度控制, dx和dy表示移动的位置，此时也随机生成 let dx = (Math.random() - 0.5) * 6 let dy = (Math.random() - 0.5) * 8 let radius = 30 //创建Circle对象，并添加到数组中 circleArray.push(new Circle(x,y,dx,dy,radius)) &#125; //**************************************************************** //**********************动画函数********************** function animate() &#123; requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; circleArray[i].update() &#125; &#125; //**********************动画函数********************** //别忘记调用 animate() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 增加新的功能 球和球之间画一条线，要实现此功能需要用到毕达哥拉斯定理，也就是勾股定理。 在遍历数组的时候，将当前球的位置和其它所有球的位置进行距离计算，如果距离小于一定值，则画一条线 计算过程如下图所示 关键代码 1234567//两点之间的距离计算//计算两个Circle 对象的 x 坐标之差const newX = circleArray[i].x - circleArray[j].x//计算两个Circle 对象的 y 坐标之差const newY = circleArray[i].y - circleArray[j].y//使用毕达哥拉斯定理，已知两边求第三边let distance = Math.sqrt(newX*newX + newY*newY) 123456789101112131415161718192021222324252627282930313233343536373839404142function animate() &#123; requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; //画图函数的调用放于此处 circleArray[i].draw() //更新 circleArray[i].update() //**************************增加的代码*************************************** //遍历当前Circle对象之外的所有Circle，计算当前Circle对象和其它每个Circle之间的距离，使用毕达哥拉斯定理(勾股定理) for (let j = i+1; j &lt; circleArray.length; j++) &#123; //两点之间的距离计算 //计算两个Circle 对象的 x 坐标之差 const newX = circleArray[i].x - circleArray[j].x //计算两个Circle 对象的 y 坐标之差 const newY = circleArray[i].y - circleArray[j].y //使用毕达哥拉斯定理，已知两边求第三边 let distance = Math.sqrt(newX*newX + newY*newY) //当粒子和粒子之间的距离小于100时画线 if(distance &lt; 100) &#123; //路径开始 ctx.beginPath() //颜色设定为当前对象的color ctx.strokeStyle = circleArray[i].color //线宽设置 ctx.lineWidth = 1 //两个点 连成一根线 ctx.moveTo(circleArray[i].x, circleArray[i].y) ctx.lineTo(circleArray[j].x, circleArray[j].y) ctx.stroke() &#125; &#125; //**************************************************************************** &#125;&#125; 计算过程如下图所示: 3. 完整代码 稍做改动，球的半径不再固定，改成随机生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy //球的半径随机设置 this.radius = Math.random() * 15 + 1 //增加一个颜色属性 this.color = &#x27;hsla(&#x27;+(Math.random()*360)+&#x27;, 100%, 50%, 0.6)&#x27; &#125; //画一个圆 draw() &#123; ctx.beginPath() //设置填充颜色 ctx.fillStyle = this.color ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 //ctx.strokeStyle = &#x27;blue&#x27; //ctx.stroke() //填充 ctx.fill() &#125; //更新圆的位置 update() &#123; //判断圆是否超出canvas边界，判断时需要将半径也算上 if(this.x + this.radius &gt; canvas.width || this.x-this.radius &lt; 0)&#123; //如果超出x轴左右两边的边界则重新设置 dx的值 this.dx = -this.dx &#125; //高度边界判断 if(this.y+this.radius &gt; canvas.height || this.y-this.radius &lt; 0) &#123; this.dy = -this.dy &#125; //更改x和y坐标 this.x += this.dx this.y += this.dy &#125; &#125; //*************************************************************** //声明一个数组 var circleArray = [] //循环50次，产生50个Circle对象 for (let i = 0; i &lt; 50; i++) &#123; //自动生成x,y坐标,范围必须在Canvas画布内 let x = Math.random() * (canvas.width-radius*2) + radius let y = Math.random() * (canvas.height-radius*2) + radius //速度控制, dx和dy表示移动的位置，此时也随机生成 let dx = (Math.random() - 0.5) * 6 let dy = (Math.random() - 0.5) * 8 let radius = 30 //创建Circle对象，并添加到数组中 circleArray.push(new Circle(x,y,dx,dy,radius)) &#125; //**************************************************************** //**********************动画函数********************** function animate() &#123; requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; //画图函数的调用放于此处 circleArray[i].draw() //更新 circleArray[i].update() //**************************增加的代码*************************************** //遍历当前Circle对象之外的所有Circle，计算当前Circle对象和其它每个Circle之间的距离，使用毕达哥拉斯定理(勾股定理) for (let j = i+1; j &lt; circleArray.length; j++) &#123; //两点之间的距离计算 //计算两个Circle 对象的 x 坐标之差 const newX = circleArray[i].x - circleArray[j].x //计算两个Circle 对象的 y 坐标之差 const newY = circleArray[i].y - circleArray[j].y //使用毕达哥拉斯定理，已知两边 let distance = Math.sqrt(newX*newX + newY*newY) //当粒子和粒子之间的距离小于100时画线 if(distance &lt; 100) &#123; //路径开始 ctx.beginPath() //颜色设定为当前对象的color ctx.strokeStyle = circleArray[i].color //线宽设置 ctx.lineWidth = 1 //两个点 连成一根线 ctx.moveTo(circleArray[i].x, circleArray[i].y) ctx.lineTo(circleArray[j].x, circleArray[j].y) ctx.stroke() &#125; &#125; //**************************************************************************** &#125; &#125; //**********************动画函数********************** //别忘记调用 animate() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 本节内容主要是平面几何中的原理应用到实际图形开发中，是不是很有趣? 在这个基础之上还可以做出更多的效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(五) JavaScript-Canvas球球乱撞","slug":"JavaScript/(5)-JavaScript-Canvas球球乱撞","date":"2022-07-21T09:00:00.000Z","updated":"2022-07-22T09:53:37.080Z","comments":true,"path":"2022/07/21/JavaScript/(5)-JavaScript-Canvas球球乱撞/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/21/JavaScript/(5)-JavaScript-Canvas%E7%90%83%E7%90%83%E4%B9%B1%E6%92%9E/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 效果图 (五) JavaScript-Canvas球球乱撞 在 JavaScript-Canvas-自由运动的球 这一节里，实现了单个球自由地在Canvas画布中运动，本节将它完善一下，创建N个球在Canvas画布中胡乱飞，见上图；这些球相互之间不会碰撞，如果需要实现这个功能，还需加点油，跟着来就对了。 本节JavaScript 技术要点 定义数组 和使用数组, 貌似一见到数组有些人就犯难了 随机设置颜色 控制一下球的运动速度(其实这算不上技术，顶多是个技巧) 1. JavaScript-Canvas-自由运动的球 最终代码如下 需要在这个代码上面增加一点内容来实现 多球自由运动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius &#125; //画一个圆 draw() &#123; ctx.beginPath() ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 ctx.strokeStyle = &#x27;blue&#x27; ctx.stroke() //填充 ctx.fill() &#125; //更新圆的位置 update() &#123; //判断圆是否超出canvas边界，判断时需要将半径也算上 if(this.x + this.radius &gt; canvas.width || this.x-this.radius &lt; 0)&#123; //如果超出x轴左右两边的边界则重新设置 dx的值 this.dx = -this.dx &#125; //高度边界判断 if(this.y+this.radius &gt; canvas.height || this.y-this.radius &lt; 0) &#123; this.dy = -this.dy &#125; //更改x和y坐标 this.x += this.dx this.y += this.dy //调用draw()函数重新画圆 this.draw() &#125; &#125; //创建一个圆 var circle = new Circle(200,200,3,3,30) //调用update函数 circle.update() //动画函数 function animate() &#123; //不断请求动画帧，每次请求都会重新调用一次animate, requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) circle.update() &#125; animate() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. Circle数组 既然要有多个球，那么可以定义一个数组，数组中的元素为Circle对象, 每个圆的初始位置都随机生成 1234567891011121314//声明一个数组var circleArray = []//循环50次，产生50个Circle对象for (let i = 0; i &lt; 50; i++) &#123; //自动生成x,y坐标,范围必须在Canvas画布内 let x = Math.random() * (canvas.width-radius*2) + radius let y = Math.random() * (canvas.height-radius*2) + radius //速度控制, dx和dy表示移动的位置，此时也随机生成 let dx = (Math.random() - 0.5) * 6 let dy = (Math.random() - 0.5) * 8 let radius = 30 //创建Circle对象，并添加到数组中 circleArray.push(new Circle(x,y,dx,dy,radius))&#125; 3. 动画函数中遍历数组 遍历数组时不断的调用 Circle对象的update()方法 12345678function animate() &#123; requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; circleArray[i].update() &#125;&#125;animate() 4. 完整代码 增加了随机颜色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius //增加一个颜色属性 this.color = &#x27;hsla(&#x27;+(Math.random()*360)+&#x27;, 100%, 50%, 0.6)&#x27; &#125; //画一个圆 draw() &#123; ctx.beginPath() //设置填充颜色 ctx.fillStyle = this.color ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 //ctx.strokeStyle = &#x27;blue&#x27; //ctx.stroke() //填充 ctx.fill() &#125; //更新圆的位置 update() &#123; //判断圆是否超出canvas边界，判断时需要将半径也算上 if(this.x + this.radius &gt; canvas.width || this.x-this.radius &lt; 0)&#123; //如果超出x轴左右两边的边界则重新设置 dx的值 this.dx = -this.dx &#125; //高度边界判断 if(this.y+this.radius &gt; canvas.height || this.y-this.radius &lt; 0) &#123; this.dy = -this.dy &#125; //更改x和y坐标 this.x += this.dx this.y += this.dy //调用draw()函数重新画圆 this.draw() &#125; &#125; //*************************************************************** //声明一个数组 var circleArray = [] //循环50次，产生50个Circle对象 for (let i = 0; i &lt; 50; i++) &#123; //自动生成x,y坐标,范围必须在Canvas画布内 let x = Math.random() * (canvas.width-radius*2) + radius let y = Math.random() * (canvas.height-radius*2) + radius //速度控制, dx和dy表示移动的位置，此时也随机生成 let dx = (Math.random() - 0.5) * 6 let dy = (Math.random() - 0.5) * 8 let radius = 30 //创建Circle对象，并添加到数组中 circleArray.push(new Circle(x,y,dx,dy,radius)) &#125; //**************************************************************** //**********************动画函数********************** function animate() &#123; requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) for (let i = 0; i &lt; circleArray.length; i++) &#123; circleArray[i].update() &#125; &#125; //**********************动画函数********************** //别忘记调用 animate() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 本节中利用数组存储了多个Circle对象，在动画函数中遍历数组并调用update方法更新 Circle的位置， 后续我们增加特效，让球和球之间有连线","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(四) JavaScript-Canvas-自由运动的球","slug":"JavaScript/(4)-JavaScript-Canvas自由运动的球","date":"2022-07-21T07:00:00.000Z","updated":"2022-07-23T00:33:56.503Z","comments":true,"path":"2022/07/21/JavaScript/(4)-JavaScript-Canvas自由运动的球/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/21/JavaScript/(4)-JavaScript-Canvas%E8%87%AA%E7%94%B1%E8%BF%90%E5%8A%A8%E7%9A%84%E7%90%83/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! 效果图 (四) JavaScript-Canvas-自由运动的球 本节将使用window.requestAnimationFrame()函数制作动画，先从简单的开始, 理解以下内容需要对JavaScript 中的函数和class有基本的了解 本节JavaScript 技术要点 使用class定义类 使用constructor定义构造函数 使用Canvas Context的 arc函数绘制圆 动画关键函数 window.requestAnimationFrame() 1. 准备HTML页面12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 创建一个圆类 使用ES6中的class关键字 定义一个圆（也可以直接使用function），一个圆需要中心坐标以及半径参数，在本例中还需要移动的距离 使用class定义圆，x,y表示圆的中心坐标，dx,dy表示移动时的横坐标和纵坐标距离 , radius表示半径 123456789class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius &#125;&#125; 使用function定义 1234567function Circle(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 定义绘制圆的函数，在Circle类中定义 绘制开始 beginPath() 绘制圆的arc函数 ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, false) this.x,this.y是指当前对象的坐标 this.radius是指当前对象的半径 0 表示开始角度 2*Math.PI 表示360度 最后个参数表示是否是逆时针方向绘制,设置为true或false均可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius &#125; draw() &#123; ctx.beginPath() ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 ctx.strokeStyle = &#x27;blue&#x27; ctx.stroke() //填充 ctx.fill() &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 圆位置变化 圆在Canvas中位置要不断的变化才能有动画效果，所以x和y坐标不是固定的，而是动态变化的，可以定义一个数不断的更新圆的x,y的值 圆的位置不能超过Canvas的宽度和高度, 判断时需要将半径也算上 增加的函数命名为update 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius &#125; //画一个圆 draw() &#123; ctx.beginPath() ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 ctx.strokeStyle = &#x27;blue&#x27; ctx.stroke() //填充 ctx.fill() &#125; //更新圆的位置 update() &#123; //判断圆是否超出canvas边界，判断时需要将半径也算上 if(this.x + this.radius &gt; canvas.width || this.x-this.radius &lt; 0)&#123; //如果超出x轴左右两边的边界则重新设置 dx的值 this.dx = -this.dx &#125; //高度边界判断 if(this.y+this.radius &gt; canvas.height || this.y-this.radius &lt; 0) &#123; this.dy = -this.dy &#125; //更改x和y坐标 this.x += this.dx this.y += this.dy //调用draw()函数重新画圆 this.draw() &#125; //创建一个圆 var circle = new Circle(200,200,3,3,30) //调用update函数 circle.update() &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如图，圆不会动，原因是update函数需要不断调用，此时只调用了一次 5. 动画 使用动画函数不断自动调用update 每次刷新update调用时都需要clear一下整个画布，试试不去调用clearRect的效果会怎样 关于动画帧函数，参考 window.requestAnimationFrame() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;padding: 0; margin: 0;&#125; #canvas &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight class Circle &#123; constructor(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius &#125; //画一个圆 draw() &#123; ctx.beginPath() ctx.arc(this.x,this.y,this.radius,0,2*Math.PI, false) //线样式 ctx.strokeStyle = &#x27;blue&#x27; ctx.stroke() //填充 ctx.fill() &#125; //更新圆的位置 update() &#123; //判断圆是否超出canvas边界，判断时需要将半径也算上 if(this.x + this.radius &gt; canvas.width || this.x-this.radius &lt; 0)&#123; //如果超出x轴左右两边的边界则重新设置 dx的值 this.dx = -this.dx &#125; //高度边界判断 if(this.y+this.radius &gt; canvas.height || this.y-this.radius &lt; 0) &#123; this.dy = -this.dy &#125; //更改x和y坐标 this.x += this.dx this.y += this.dy //调用draw()函数重新画圆 this.draw() &#125; &#125; //创建一个圆 var circle = new Circle(200,200,3,3,30) //调用update函数 circle.update() //动画函数 function animate() &#123; //不断请求动画帧，每次请求都会重新调用一次animate, requestAnimationFrame(animate) ctx.clearRect(0,0,canvas.width,canvas.height) circle.update() &#125; animate() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如此文开头的动图，如果注释掉ctx.clearRect(0,0,canvas.width,canvas.height) 你将得到以下结果 加上数组，再加上随机颜色的变化，就可以产生下图的效果了 动画相对静态的图形稍麻烦一点，但若是掌握了requestAnimationFrame以及背后的原理，实现动画就简单多了，当然，也可以使用setTimeout或setInterval，大伙可以试试","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(三)  JavaScript Canvas 画多边形-多角星","slug":"JavaScript/(3)-JavaScript-Canvas画多边形","date":"2022-07-21T02:02:00.000Z","updated":"2022-07-22T04:29:06.941Z","comments":true,"path":"2022/07/21/JavaScript/(3)-JavaScript-Canvas画多边形/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/21/JavaScript/(3)-JavaScript-Canvas%E7%94%BB%E5%A4%9A%E8%BE%B9%E5%BD%A2/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! (二) JavaScript Canvas 画多边形-多角星1. 准备HTML页面123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; overflow: hidden; background-color: black; &#125; #canvas1 &#123; background-color: white; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas1.getContext(&#x27;2d&#x27;) console.log(canvas1) console.log(ctx); //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 绘制六角星形 多边形由线组成，先把第一根线画好，此处选择从中心点向上绘制 初始坐标为(0,0) 此时设置为画布Canvas的中心点 123456789101112131415161718192021222324&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.beginPath() //平移到canvas中心点 ctx.translate(canvas.width/2, canvas.height/2) //设置颜色为红色 ctx.strokeStyle=&#x27;red&#x27; //设置线宽 ctx.lineWidth = 3 //移动到坐标(0,0) ctx.moveTo(0, 0) //结束坐标 ctx.lineTo(0, -100) //画线 ctx.stroke() &lt;/script&gt; 效果如下图所示 下面再画第二根线，要注意的是不要closePath()，让第二根线从第一根线的结束点开始画，也就是从(0, -100)开始 绘制时需要旋转, 旋转会将整个坐标系旋转具体角度或弧度 12345678910111213141516171819202122232425262728&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.beginPath() //平移到canvas中心点 ctx.translate(canvas.width/2, canvas.height/2) //设置颜色为红色 ctx.strokeStyle=&#x27;red&#x27; //设置线宽 ctx.lineWidth = 3 //移动到坐标(0,0) ctx.moveTo(0, 0) //结束坐标 ctx.lineTo(0, -100) //绘制第二根线 ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) //画线 ctx.stroke() &lt;/script&gt; 如下图所示，第二根线的开始点为(0, -100) 结束点为 (0, -50), 整个坐标系rotate (旋转) 了 Math.PI/6 个角度 rotate 前和rotate 后的坐标系如图所示，蓝色表示是rotate 前, 红色表示rotate后 接下来再用同样的方法，先rotate,然后再设定结束坐标 12345678910111213141516171819202122232425262728293031&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.beginPath() //平移到canvas中心点 ctx.translate(canvas.width/2, canvas.height/2) //设置颜色为红色 ctx.strokeStyle=&#x27;red&#x27; //设置线宽 ctx.lineWidth = 3 //移动到坐标(0,0) ctx.moveTo(0, 0) //结束坐标 ctx.lineTo(0, -100) //绘制第二根线 ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) //绘制第三根线 ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) //画线 ctx.stroke() &lt;/script&gt; 效果如下图所示 接下来就只需要重复以上第二根线和第三根线的绘制步骤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.beginPath() //平移到canvas中心点 ctx.translate(canvas.width/2, canvas.height/2) //设置颜色为红色 ctx.strokeStyle=&#x27;red&#x27; //设置线宽 ctx.lineWidth = 3 //移动到坐标(0,0) ctx.moveTo(0, 0) //结束坐标 ctx.lineTo(0, -100) //绘制第二根线 ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) //绘制第三根线 ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) //重复以上两根线的绘制 ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) //画线 ctx.stroke() &lt;/script&gt; 结果如下图所示, 六边形就画成了，但是多了一根线，可以直接将这行代码ctx.moveTo(0, 0) 注释掉即可 3. 使用循环实现 上面代码可以使用循环实现 1234567891011121314151617181920212223242526272829&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight ctx.beginPath() //平移到canvas中心点 ctx.translate(canvas.width/2, canvas.height/2) //设置颜色为红色 ctx.strokeStyle=&#x27;red&#x27; //设置线宽 ctx.lineWidth = 3 ctx.lineTo(0, -100) for(let i=0;i&lt;6;i++) &#123; ctx.rotate(Math.PI/6) ctx.lineTo(0, -50) ctx.rotate(Math.PI/6) ctx.lineTo(0, -100) &#125; ctx.stroke() //画线 ctx.stroke() &lt;/script&gt; 效果和上面一样，还可以改成7角星或更多角,只需要改一个数字即可 将6更改为10 123456for(let i=0;i&lt;10;i++) &#123; ctx.rotate(Math.PI/10) ctx.lineTo(0, -50) ctx.rotate(Math.PI/10) ctx.lineTo(0, -100)&#125; 4. 定义函数绘制多边形或多角星 定义成函数后，更改几个参数就可以绘制出不同的形状 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; overflow: hidden; background-color: black; &#125; #canvas &#123; background-color: white; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) //定义画布Canvas的宽和高 canvas.width = window.innerWidth canvas.height = window.innerHeight //x,y也可以为任意值,此处是将其平移动中心位置 let x = canvas.width/2 let y = canvas.height/2 //绘制一个八角形,第四个参数如果是等于1时将会是一个多边形 drawShape(x, y, 50, 1.5, 8) function drawShape(x, y, radius, inset, n) &#123; ctx.fillStyle = &#x27;hsl(3,100%,50%)&#x27; ctx.beginPath() ctx.save() ctx.translate(x,y) //平移到x,y的位置 ctx.moveTo(0, 0-radius) //开始点 如果radius为100此时的坐标就为 (0,-100) for(let i=0;i&lt;n;i++) &#123; ctx.rotate(Math.PI/n)//旋转 ctx.lineTo(0, 0-radius*inset) //中心点和内角点的距离 ctx.rotate(Math.PI/n) ctx.lineTo(0, 0-radius) //中心点和外角点的距离 &#125; ctx.restore() ctx.closePath() ctx.stroke() ctx.fill()//填充 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 调用时可传递不同的参数值，看看效果吧 drawShape(x, y, 50, 1.5, 8) drawShape(x, y, 50, 1.5, 8) drawShape(x, y, 100, 2.8, 5) 以上均为绘图基础，为后续绘制复杂的图形和动画打好基础. 最后一个函数稍微复杂一点点。用到的技术也就是前面篇章里介绍的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(二)  JavaScript Canvas 画矩形","slug":"JavaScript/(2)-JavaScript-Canvas画矩形","date":"2022-07-20T04:02:00.000Z","updated":"2022-07-21T12:04:14.161Z","comments":true,"path":"2022/07/20/JavaScript/(2)-JavaScript-Canvas画矩形/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/20/JavaScript/(2)-JavaScript-Canvas%E7%94%BB%E7%9F%A9%E5%BD%A2/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! (二) JavaScript Canvas 画矩形1. 准备HTML页面1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; canvas &#123; position: absolute; background: white; width: 100%; height: 100%; top: 0; left: 0; &#125; canvas &#123; background: linear-gradient(120deg, #4a3934, #e6d5b9); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt; 2. 画矩形 掌握几个函数 translate() 平移坐标原点到指定坐标位置 moveTo(0, 0) 移动到坐标位置(0, 0) beginPath() 开始路径 closePath() 关闭路径 rotate() 旋转 save() 在中心点画一个矩形 使用平移函数 translate() 和 绘制矩形函数rect() 1234567891011121314151617&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移 ctx.translate(canvas.width/2, canvas.height/2) //将坐标设定为(0,0) 也就是平移后的中心 ctx.moveTo(0, 0) //设置颜色 ctx.strokeStyle = &#x27;black&#x27; //画矩形 坐标和长宽 ctx.rect(0,0,200,200) ctx.stroke()&lt;/script&gt; 效果如下图: 在上一个矩形之后再画一个矩形,改变一下颜色和旋转的角度 123456789101112131415161718192021222324252627&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移 ctx.translate(canvas.width/2, canvas.height/2) //将坐标设定为(0,0) 也就是平移后的中心 ctx.moveTo(0, 0) //设置颜色 ctx.strokeStyle = &#x27;black&#x27; //画矩形 坐标和长宽 ctx.rect(0,0,200,200) ctx.stroke() //一个新的矩形 //旋转一定角度 ctx.rotate(30 * Math.PI/180) //设定颜色 ctx.strokeStyle = &#x27;red&#x27; //绘制矩形 ctx.rect(0,0,200,200) ctx.stroke()&lt;/script&gt; 看看效果, 你会发现，两个矩形边框的颜色是最后一次设定的红色, 怎么解决? 其实和画线那篇类似，使用beginPath() 使用beginPath() 重新开始 123456789101112131415161718192021222324252627282930&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移 ctx.translate(canvas.width/2, canvas.height/2) //将坐标设定为(0,0) 也就是平移后的中心 ctx.moveTo(0, 0) //设置颜色 ctx.strokeStyle = &#x27;black&#x27; //画矩形 坐标和长宽 ctx.rect(0,0,200,200) ctx.stroke() //一个新的矩形 ctx.beginPath() //重新开始新的设置，原来的设置（比如颜色）将不会影响后续图形 //旋转一定角度 ctx.rotate(30 * Math.PI/180) //设定颜色 ctx.strokeStyle = &#x27;red&#x27; //绘制矩形 ctx.rect(0,0,200,200) ctx.stroke() //此行可以写也可以省略 ctx.closePath()&lt;/script&gt; 如下图所示 再画第三个矩形，同时的旋转角度, 边框颜色设定为 blue 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移 ctx.translate(canvas.width/2, canvas.height/2) //将坐标设定为(0,0) 也就是平移后的中心 ctx.moveTo(0, 0) //设置颜色 ctx.strokeStyle = &#x27;black&#x27; //画矩形 坐标和长宽 ctx.rect(0,0,200,200) ctx.stroke() //一个新的矩形 ctx.beginPath() //重新开始新的设置，原来的设置（比如颜色）将不会影响后续图形 //旋转一定角度 ctx.rotate(30 * Math.PI/180) //设定颜色 ctx.strokeStyle = &#x27;red&#x27; //绘制矩形 ctx.rect(0,0,200,200) ctx.stroke() //此行可以写也可以省略 ctx.closePath() ctx.beginPath() ctx.rotate(30 * Math.PI/180) ctx.strokeStyle = &#x27;blue&#x27; ctx.rect(0,0,200,200) ctx.stroke() ctx.closePath()&lt;/script&gt; 可以看到，旋转的角度是相对于上一个矩形，如果不使用save() restore()方法，那么旋转时将相对于上次绘制的形状 在绘制中间的那个矩形时使用save() 和 restore()包裹起来，看看有什么不一样 123456789101112131415161718192021222324252627282930313233343536373839&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移 ctx.translate(canvas.width/2, canvas.height/2) //将坐标设定为(0,0) 也就是平移后的中心 ctx.moveTo(0, 0) //设置颜色 ctx.strokeStyle = &#x27;black&#x27; //画矩形 坐标和长宽 ctx.rect(0,0,200,200) ctx.stroke() //一个新的矩形 ctx.save() ctx.beginPath() //重新开始新的设置，原来的设置（比如颜色）将不会影响后续图形 //旋转一定角度 ctx.rotate(30 * Math.PI/180) //设定颜色 ctx.strokeStyle = &#x27;red&#x27; //绘制矩形 ctx.rect(0,0,200,200) ctx.stroke() //此行可以写也可以省略 ctx.closePath() ctx.restore() ctx.beginPath() ctx.rotate(30 * Math.PI/180) ctx.strokeStyle = &#x27;blue&#x27; ctx.rect(0,0,200,200) ctx.stroke() ctx.closePath()&lt;/script&gt; 绘制结果如下，第二个矩形和第三个矩形重合了，可以这样理解，第三个矩形认为第二个矩形不存在一样，绘制时旋转角度就依赖于第一个矩形 通过循环绘制矩形 12345678910111213141516171819202122232425&lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; */ const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight drawRect() function drawRect() &#123; //平移 ctx.translate(canvas.width/2, canvas.height/2) //将坐标设定为(0,0) 也就是平移后的中心 ctx.moveTo(0, 0) ctx.translate(canvas.width/2, canvas.height/2) ctx.moveTo(0, 0) for(let i=0;i&lt;8;i++) &#123; ctx.strokeStyle = &#x27;hsl(&#x27; + Math.random()*360 + &quot;,100%,50%)&quot; ctx.rect(0,0,200,200) ctx.rotate(30*Math.PI/180) ctx.stroke() &#125; &#125;&lt;/script&gt; 效果如图，注意没有增加save()和restore()方法 save()和restore()经常在矩阵变换 translate()、缩放 scale()、旋转rotate()中使用, 因为一个Canvas只有一个2d上下文，当执行转换操作时，整个上下文的坐标系都将改变。改变后，如果我们需要将坐标系恢复到原来正常的状态，这时就需要用到save() 和 restore(), 下图中第一次绘制矩形的坐标系和旋转后绘制矩形的坐标系 以上均为绘图基础，为后续绘制复杂的图形和动画打好基础","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"(一)  JavaScript Canvas 画线","slug":"JavaScript/(1)-JavaScript-Canvas画线","date":"2022-07-19T13:02:13.000Z","updated":"2022-07-21T04:12:04.361Z","comments":true,"path":"2022/07/19/JavaScript/(1)-JavaScript-Canvas画线/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/19/JavaScript/(1)-JavaScript-Canvas%E7%94%BB%E7%BA%BF/","excerpt":"","text":"JavaScript 是前端核心， 掌握这门语言是步入前端高手行列必经之路，噢，别忘了还有TypeScript, 学习它还需要OOP知识， 底层的浏览器原理、HTTP协议也必不可少， 此系列文章记录使用JavaScript和Canvas进行游戏开发, 有游戏才有趣!!! (一) JavaScript Canvas 画线1. 准备HTML页面1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; canvas &#123; position: absolute; background: white; width: 100%; height: 100%; top: 0; left: 0; &#125; canvas &#123; background: linear-gradient(120deg, #4a3934, #e6d5b9); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt; 2. 画线 掌握几个函数 translate() 平移坐标原点到指定坐标位置 moveTo(0, 0) 移动到坐标位置(0, 0) beginPath() 开始路径 closePath() 关闭路径 rotate() 旋转 save() 画一根线 123456789101112131415161718 &lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) //从中心点到 (200, 0) 这个位置画一根线 ctx.moveTo(0, 0) ctx.lineTo(200, 0) //设定线的颜色样式 为 黑色 ctx.strokeStyle = &quot;black&quot; //设定线宽 ctx.lineWidth = 5 ctx.stroke()&lt;/script&gt; 如下图所示,注意此时并没有使用beginPath()也没有使用closePath() 在第一根线的基础上, 再画一根线 1234567891011121314151617181920212223 &lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) //从中心点到 (200, 0) 这个位置画一根线 ctx.moveTo(0, 0) ctx.lineTo(200, 0) //设定线的颜色样式 为 黑色 ctx.strokeStyle = &quot;black&quot; //设定线宽 ctx.lineWidth = 5 ctx.stroke() ctx.strokeStyle = &quot;red&quot; ctx.lineTo(200, 30) ctx.lineWidth = 5 ctx.stroke() &lt;/script&gt; 结果如图所示: 第一根线的样式完全变成了第二根线的样式，原因是画完第一根线时并没有关闭路径，也就是没有调用closePath()方法，导致第二根线的起始点会在第一根的结束坐标开始 在画完第一根线后closePath(), 关闭路径后，下一根线的起点将从原点(0,0)开始, 但是第一根线的颜色从black变成了red 123456789101112131415161718192021222324 &lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) //从中心点到 (200, 0) 这个位置画一根线 ctx.moveTo(0, 0) ctx.lineTo(200, 0) //设定线的颜色样式 为 黑色 ctx.strokeStyle = &quot;black&quot; //设定线宽 ctx.lineWidth = 10 ctx.stroke() ctx.closePath() //关闭路径 ctx.strokeStyle = &quot;red&quot; ctx.lineTo(200, 20) ctx.lineWidth = 5 ctx.stroke() &lt;/script&gt; 为了让每一根线的样子能独立出来，相互不影响，需要使用beginPath() 顾名思义就是开始路径 1234567891011121314151617181920212223242526272829&lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) //第一根线路径开始 ctx.beginPath() //从中心点到 (200, 0) 这个位置画一根线 ctx.moveTo(0, 0) ctx.lineTo(200, 0) //设定线的颜色样式 为 黑色 ctx.strokeStyle = &quot;black&quot; //设定线宽 ctx.lineWidth = 10 ctx.stroke() ctx.closePath() //关闭路径 //第二根线路径开始 ctx.beginPath() ctx.strokeStyle = &quot;red&quot; ctx.moveTo(0,0) //或者直接使用lineTo(0,0) ctx.lineTo(200, 20) ctx.lineWidth = 5 ctx.stroke() &lt;/script&gt; 下面利用旋转函数rotate画出下面的图形, 需要知晓以下数学知识 1弧度是 大约 57.2958角度 将弧度转换为角度：乘以 180，除以 π 将角度转换为弧度：乘以 π，除以 180 弧度是基于圆的半径的纯计量单位 在一个半圆上有 π 弧度，也等于 180°, 所以: π 弧度 = 180° 那么 : 1弧度 = 180°/π = 57.2958……° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) //第一根线路径开始 ctx.beginPath() //从中心点到 (200, 0) 这个位置画一根线 ctx.moveTo(0, 0) ctx.lineTo(200, 0) //设定线的颜色样式 为 黑色 ctx.strokeStyle = &quot;black&quot; //设定线宽 ctx.lineWidth = 10 ctx.stroke() ctx.closePath() //关闭路径 //第二根线路径开始 ctx.beginPath() //旋转30度 30*Math.PI/180 是一个转换公式 ctx.rotate(30*Math.PI/180) ctx.strokeStyle = &quot;red&quot; ctx.moveTo(0,0) ctx.lineTo(200, 0) ctx.lineWidth = 5 ctx.stroke() //第三根线路径开始 ctx.beginPath() ctx.rotate(30*Math.PI/180) ctx.strokeStyle = &quot;yellow&quot; ctx.moveTo(0,0) ctx.lineTo(200, 0) ctx.lineWidth = 5 ctx.stroke() //第四根线路径开始 ctx.beginPath() ctx.rotate(30*Math.PI/180) ctx.strokeStyle = &quot;pink&quot; ctx.moveTo(0,0) ctx.lineTo(200, 0) ctx.lineWidth = 5 ctx.stroke() &lt;/script&gt; 如果再加上**ctx.save()和ctx.restore()**函数，看看有什么区别? 把第三根线加上save和restore方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) //第一根线路径开始 ctx.beginPath() //从中心点到 (200, 0) 这个位置画一根线 ctx.moveTo(0, 0) ctx.lineTo(200, 0) //设定线的颜色样式 为 黑色 ctx.strokeStyle = &quot;black&quot; //设定线宽 ctx.lineWidth = 10 ctx.stroke() ctx.closePath() //关闭路径 //第二根线路径开始 ctx.beginPath() //旋转30度 30*Math.PI/180 是一个转换公式 ctx.rotate(30*Math.PI/180) ctx.strokeStyle = &quot;red&quot; ctx.moveTo(0,0) ctx.lineTo(200, 0) ctx.lineWidth = 5 ctx.stroke() //第三根线路径开始 ctx.save() ctx.beginPath() ctx.rotate(30*Math.PI/180) ctx.strokeStyle = &quot;yellow&quot; ctx.moveTo(0,0) ctx.lineTo(200, 0) ctx.lineWidth = 5 ctx.stroke() ctx.restore() //第四根线路径开始 ctx.beginPath() ctx.rotate(30*Math.PI/180) ctx.strokeStyle = &quot;pink&quot; ctx.moveTo(0,0) ctx.lineTo(200, 0) ctx.lineWidth = 5 ctx.stroke() &lt;/script&gt; 结果是第四根线不再依据第三根线旋转角度，而是依据第二根红线旋转角度，对于第四根线来说就好像第三根线不存在一样, 据此可以明白save() restore()的作用 利用函数+循环实现，颜色使用HSL随机 12345678910111213141516171819202122232425&lt;script&gt; const canvas = document.getElementById(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = window.innerWidth canvas.height = window.innerHeight //平移到坐标canvas中心点，那么原点就是此坐标点 ctx.translate(canvas.width/2, canvas.height/2) drawLine(); function drawLine() &#123; ctx.translate(canvas.width/2, canvas.height/2) for(let i=0;i&lt;12;i++) &#123; ctx.beginPath() ctx.strokeStyle = &#x27;hsl(&#x27;+Math.random()*360+&quot;,100%,50%)&quot; ctx.lineWidth = 5 ctx.rotate(30*Math.PI/180) ctx.lineTo(0, 0) ctx.lineTo(200, 0) ctx.stroke() ctx.closePath() &#125; &#125;&lt;/script&gt; 效果如下图: 利用上面所了解的知识点，能画出一个五角星吗? 下一篇来试试","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"JavaFX扫雷","slug":"Java/JavaFX扫雷","date":"2022-07-18T08:02:13.000Z","updated":"2022-07-19T03:22:27.061Z","comments":true,"path":"2022/07/18/Java/JavaFX扫雷/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/18/Java/JavaFX%E6%89%AB%E9%9B%B7/","excerpt":"","text":"windows系统上经典扫雷游戏，1992年4月6日，扫雷和纸牌、空当接龙等小游戏搭载在Windows 3.1系统中与用户见面，主要目的是让用户训练使用鼠标。这个游戏的玩法很简单，有初级、中级、高级和自定义等模式，雷区中随机布置一定数量的地雷，玩家需要尽快找出所有不是地雷的方块，但不许踩到地雷。这里我们使用Java和JavaFX实现一个简易版的扫雷程序，先理解扫雷游戏逻辑，练习使用Java中的循环、数组、二维数组、集合、面向对象、Stream、递归等技术实现游戏功能。 游戏逻辑 需要一个图形界面，使用JavaFX实现 需要在图形界面中定义一个 N * N 的网格， N可以是任意设置 N * N个格子中有三个内容： 空白、数字(表示周围8个格子有多少个雷)、雷 在N * N个格子中随机生成雷 在N * N个格子中的不是雷的格子中设置相应的数字，这个数字表示当前格子周围8个格子有多少个雷 玩家在点击某一个格子时显示的是数字，比如说 显示的是2，表示周围八个格子中有两个雷 如果玩家点击的格子显示为空白，那么会要把周围8个格子全部显示，如果周围8个格子有空白格子，又需要将空白格子周围8个格子全部显示，依次类推 如果玩家点击的位置是雷，游戏结束 游戏实现1. 创建JavaFX Module 参考 Java模块化编程 修改module-info.java文件，添加javafx模块支持 123456789101112131415//module声明一个模块 加上 opens 关键词表示模块内的所有包都允许通过 Java 反射访问 module example.fxdemo &#123; //声明模块依赖 requires javafx.controls; requires javafx.fxml; requires javafx.swing; //开放模块内的包, 允许通过java反射访问，一次开放一个包,如果外部使用了open,那么内部将不能使用opens opens com.example.fxdemo to javafx.fxml,javafx.controls; opens com.example to javafx.fxml; //导出这个包com.example.game，以便别的模块可以使用 exports com.example.game; &#125; 2. 工程结构123456src -main -java com.example.game MinesweeperGame module-info.java 3. 代码实现 创建游戏界面 1234567891011121314151617181920212223242526272829303132333435363738public class MinesweeperGame extends Application &#123; //Tile数量 private static final int TILE_SIZE = 40; //界面宽和高 private static final int W = 800; private static final int H = 600; //x轴上 20个格子(tile) private static final int X_TILES = W / TILE_SIZE; //y轴上 15个格子(tile) private static final int Y_TILES = H / TILE_SIZE; //UI 场景对象 private Scene scene; //此方法用于创建一个面板Pane N*N个格子会绘制在里边 private Parent createContent() &#123; Pane root = new Pane(); root.setPrefSize(W, H); return root; &#125; @Override public void start(Stage stage) throws Exception &#123; //根据面板创建场景对象 scene = new Scene(createContent()); //设置舞台Stage标题 stage.setTitle(&quot;扫雷游戏&quot;); //设置舞台场景 stage.setScene(scene); //显示 stage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 运行结果如下图所示: 创建Tile类 此类定义成内部类 使用面向对象技术创建一个Tile类，这个类需要绘制到上面所定义的面板Pane上面，而且Tile内部还需要绘制其它内容，比如数字和雷，所以此类继承 StackPane，每一个Tile类对象都表示一个格子, Tile中文意思是砖块。 每一个Tile对象需包含坐标x,y 是否有雷 hasBomb, 是否是打开的isOpen(玩家点击的时候才会打开) 每一个Tile对象还需要包含一个文本区域用于设置数字，周围还需要绘制一个矩形边框增强效果，此时需要用到图形界面JavaFX技术 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private class Tile extends StackPane &#123; //每个Tile对象的坐标 private int x, y; //是否有雷 private boolean hasBomb; //是否打开,默认为false private boolean isOpen = false; //定义矩形边框 private Rectangle border = new Rectangle(TILE_SIZE - 2, TILE_SIZE - 2); //文本对象,用于设置格子中的数字等 private Text text = new Text(); //构造函数，用于初始化坐标位置和是否有雷 public Tile(int x, int y, boolean hasBomb) &#123; this.x = x; this.y = y; this.hasBomb = hasBomb; //UI 设置格子的边框颜色，颜色使用Colod类静态预定义值 border.setStroke(Color.LIGHTGRAY); //设置文本字体大小 使用 Font类中中的font静态方法 text.setFont(Font.font(18)); //设置文本框中的内容，此时判断hasBomb值，如果为真则表示有雷，此处用X表示雷,如果为false表示没有雷，文本内容则为空 text.setText(hasBomb ? &quot;X&quot; : &quot;&quot;);//X表示雷 //默认不显示文本 text.setVisible(false); //设置矩形的透明度 border.setOpacity(0.8); //当前是一个StackPane面板容器，需要将矩形和文本组件添加到面板容器中，而且面板容器是一个Stack（栈）,根据栈的特性，最后添加进去的在最上面 getChildren().addAll(border, text); //设置当前Tile对象的x和y的位置,用处是绘制每一个StackPane也就是Tile, 每一个格子定义了一个值为TILE_SIZE=40 setTranslateX(x * TILE_SIZE); setTranslateY(y * TILE_SIZE); //为每一个Tile格子对象注册一个事件，当点击的时候调用open方法，此时需要判断格子是不是打开的，利用isOpen属性 setOnMouseClicked(e -&gt; open()); &#125; public void open() &#123; //如果是打开的则直接返回,不再执行后续逻辑 if (isOpen) return; //如果点到了雷，则游戏结束 if (hasBomb) &#123; System.out.println(&quot;Game Over&quot;); //重新再创建一个内容,重新设置场景，也可以通过按钮点击时重新设置 scene.setRoot(createContent()); return; &#125; //如果前两个判断都没进入则表示Tile格子未翻开，设置isOpen为true,表示已打开，然后显示文本内容，并让矩形的填充内容为空 isOpen = true; text.setVisible(true); border.setFill(null); //如果点击时Text内容是空的，那么需要显示周围8个格子 if (text.getText().isEmpty()) &#123; //此处需要找到周围的8个Tile对象，遍历每一个，并判断是不是空格，如果是空格则需要再次执行getNeighbors方法 //getNeighbors方法用于查找相邻的8个Tile格子 //forEach语法是Java8之后的新语法，遍历每一个Tile格子对象时都会调用它的open方法 getNeighbors(this).forEach(Tile::open); &#125; &#125;&#125; 实现查找空白Tile相邻的8个Tile 123456789101112131415161718192021222324252627282930313233343536373839404142//需要在MinesweeperGame类中定义属性 Tile类型的二维数组 20x15 存储Tile对象private Tile[][] grid = new Tile[X_TILES][Y_TILES];/** * 查找周边八个tile方格是不是雷 * 定义一个二维数组, 数组的每二个值表示一个tile的周围八个格子的坐标 */private List&lt;Tile&gt; getNeighbors(Tile tile) &#123; //存储邻居tile块使用集合ArrayList存储，并用接口List引用,&lt; &gt; 表示泛型， Tile是内部类 List&lt;Tile&gt; neighbors = new ArrayList&lt;&gt;(); //定义一个数组，每两个元素分别表示当前格子和其它8个格子的坐标差 int[] points = new int[] &#123; -1, -1, -1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1 &#125;; //遍历这个数组 for (int i = 0; i &lt; points.length; i++) &#123; //每两个元素表示一个坐标,所以dx为points[i], dy则为points[++i] int dx = points[i]; int dy = points[++i]; //计算新的tile格子坐标,当前格子的坐标值加上dx,dy int newX = tile.x + dx; int newY = tile.y + dy; //此处X_TILES=20, Y_TILES=15 //判断每个新的Tile对象的坐标是否超出范围,如果没有超出范围则加到ArrayList集合中 if (newX &gt;= 0 &amp;&amp; newX &lt; X_TILES &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; Y_TILES) &#123; //grid是一个存储了所有tile对象的二维数组 neighbors.add(grid[newX][newY]);//将周边的Tile添加到集合中 &#125; &#125; //返回相邻元素的集合 return neighbors;&#125; 修改createContent方法，创建界面内容 1234567891011121314151617181920212223242526272829303132333435363738private Parent createContent() &#123; //创建内容面板,用于放置其它界面元素 Pane root = new Pane(); //设置宽高 root.setPrefSize(W, H); //嵌套循环遍历 for (int y = 0; y &lt; Y_TILES; y++) &#123; for (int x = 0; x &lt; X_TILES; x++) &#123; //创建Tile对象 //第三个参数表示是否有雷，此时用一个简单的方式设置雷，当随机数小于0.3时表示有雷 Tile tile = new Tile(x, y, Math.random() &lt; 0.3); //将每一个tile对象存储在二维数组中,二维数组中的每一个元素都表示一个tile grid[x][y] = tile; //将元素添加到root root是一个Pane root.getChildren().add(tile); &#125; &#125; //遍历二维数组，判断每一个tile是不是雷,如果是雷则continue,否则需要计算当前tile边上雷的数量 for (int y = 0; y &lt; Y_TILES; y++) &#123; for (int x = 0; x &lt; X_TILES; x++) &#123; Tile tile = grid[x][y]; //有雷则循环continue if (tile.hasBomb) continue; //找雷是为了设置tile砖块中的数字 //如果不是雷，则需要计算它周边有多少个雷,调用getNeighbors方法 //此处用到了Java8中的stream以及箭头函数等 long bombs = getNeighbors(tile).stream().filter(t -&gt; t.hasBomb).count(); //如果周边雷的数量大于0则将tile对象中的文本框设置为雷的数量 if (bombs &gt; 0) tile.text.setText(String.valueOf(bombs)); &#125; &#125; return root;&#125; 完成并总结 其实扫雷游戏的实现并不难，只需要掌握最基础的Java技术便能实现 创建类以及定义属性和行为、 使用JavaFX制作图形界面 一维数组和二维数组的定义和赋值 Java8中的新特性 forEach, stream, 箭头函数等","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"Java 模块化编程","slug":"Java/Java模块化","date":"2022-07-17T03:44:51.934Z","updated":"2022-07-18T04:51:53.410Z","comments":true,"path":"2022/07/17/Java/Java模块化/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/Java%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"现在，Java每半年发布一个版本，知道为什么这么快吗？这主要得益于Java的模块化技术。 换作以前，时间得以【年】计算。 从本质上讲，模块化(modularization） 是指将系统分解成独立且相互连接的模块的行为。模抉（ module） 是包含代码的可识别部分，使用元数据来描述模块与其它模块之间的关系。在Java 模块系统之前， JDK 的运行时库由一个庞大的rt.jar 所组成，其大小超过60MB ，包含了Java 大部分运行时类： 即Java 平台的最终载体。为了获得一个灵活且符合未来发展方向的平台， JDK 团队着手对JDK 进行模块化。模块化可以将jar声明为模块，它将在其自己的隔离类加载器中运行，该类加载器以OSGI方式从其他类似的模块类加载器读取类文件。这将允许同一版本的Jar的多个版本共存。 毕竟Java太庞大，模块化过程持续了几年时间，最终随Java9发布. Java9模块化系统出现以前Java模块化的核心三原则: 组合使用package和访问修饰符(public,protected,private)可以实现类型封装 定义良好的接口, 也就是使用interface关键字公开公共接口 显式依赖，也就是使用import关键字 Java9之后模块化 JDK 由大约90个模抉组成，而不是一个整体库。与可由自己创建的应用程序模块不同的是，平台模块是JDK的一部分。从技术上讲，平台模块和应用模块之间没有任何技术区别。每个平台模块都构成了JDK 的一个定义良好的功能块，从日志记录到XML 支持。所有模块都显式地定义了与其他模块的依赖关系。 模块工作原理 什么是模块，它是如何定义的？模块拥有一个名称，并对相关的代码以及可能的其他资源进行分组，使用一个模块描述符进行描述。模块描述符保存在一个名为 module-info.java 的文件中, 为此我们先创建一个Project,然后在Project下创建两个module, 如图所示: 创建一个Project jfxdemo 在这个jfxdemo工程下创建二个javafx module, 以下是第一个模块demo1 第二个模块 demo2 创建完成后可以发现，每个module下都有一个模块描述文件 module-info.java 此处我们使用javafx是为了后续开发游戏做准备，同时Javafx库默认情况下不能直接在应用程序中使用，必须使用模块描述文件来导入 查看demo1模块的module-info.java文件 123456module com.example1.demo1 &#123; requires javafx.controls; requires javafx.fxml; opens com.example.demo1 to javafx.fxml; exports com.example1.demo1;&#125; module-info.java文件中的第一行表示，当前应用是一个模块，模块名为 com.example.demo1, 模块名称虽然随便写个字符串也可以，但最好以域名作为基础，也就是使用反向DNS符号来确保模块的唯一性，后面紧跟着项目名称，建议尽量使用自己的域名。模块都位于一个全局命名空间中，因此，模块名称必须唯一。 requires 表示一个依赖关系，此是表示当前应用程序需要使用到javafx.controls模块以及javafx.xml模块,如果将这两句代码删除，那么在需要引用这两个模块的类中将会提示错误, 如下图所示 : 注释了requires javafx.fxml; 在HelloApplication中将无法使用 exports的意思是来自com.example.demo1模块的单个包被导出到其它模块 opens表示com.example.demo1中的类型可用于深度反射 模块化开发 在demo2模块中需要使用demo1模块中的定义的类 demo1模块中的module-info.java配置如下: 123456module com.example.demo1 &#123; requires javafx.controls; requires javafx.fxml; opens com.example.demo1 to javafx.fxml; exports com.example.demo1;&#125; 在module demo2中的pom.xml文件中加入demo1的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在demo2中要使用demo1模块中的类，则需要在demo2 模块中修改module-info.java文件 12345678module com.example.demo2 &#123; requires javafx.controls; requires javafx.fxml; requires com.example.demo1; //引入名称为com.example.demo1的模块 opens com.example.demo2 to javafx.fxml; exports com.example.demo2;&#125; 在demo2模块中的HelloApplication中使用demo1模块中的类 123456789101112131415161718192021222324package com.example.demo2;import javafx.application.Application;import javafx.fxml.FXMLLoader;import javafx.scene.Scene;import javafx.stage.Stage;import java.io.IOException;import com.example.demo1.*; //此处引用demo1模块APIpublic class HelloApplication extends Application &#123; @Override public void start(Stage stage) throws IOException &#123; FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource(&quot;hello-view.fxml&quot;)); Scene scene = new Scene(fxmlLoader.load(), 320, 240); stage.setTitle(&quot;Hello!&quot;); stage.setScene(scene); stage.show(); &#125; public static void main(String[] args) &#123; launch(); &#125;&#125; 如果在demo1模块中新建两个包，demo2模块中需要引用则要在demo1模块的module-info.java 文件中加入exports demo2模块中的HelloApplication 1234567891011121314151617181920212223242526package com.example.demo2;import javafx.application.Application;import javafx.fxml.FXMLLoader;import javafx.scene.Scene;import javafx.stage.Stage;import java.io.IOException;import com.example.demo1.*;import com.example.demo1.service.*;import com.example.demo1.dao.*;public class HelloApplication extends Application &#123; @Override public void start(Stage stage) throws IOException &#123; FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource(&quot;hello-view.fxml&quot;)); Scene scene = new Scene(fxmlLoader.load(), 320, 240); stage.setTitle(&quot;Hello!&quot;); stage.setScene(scene); stage.show(); &#125; public static void main(String[] args) &#123; launch(); &#125;&#125; 上面的内容中使用了java11进行模块化开发的第一步，也就是手动编写自己的第一个模块，而不仅仅是查看JDK中现有的模块。有了这部分经验后，后续就可以创建更加复杂的模块","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程-猜数字","slug":"Java/玩游戏学编程","date":"2022-07-17T01:19:56.088Z","updated":"2021-11-30T06:07:33.303Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一些编程初学者的痛点在于认识的英语单词太少，不知道程序在运行过程中需要什么？通过开发游戏学习编程，是一个快速但又不会觉得枯燥的方法；在这篇简单的猜数字游戏中，来看看程序开发过程中逻辑是怎样形成的？为了达到期望的结果，需要做哪些工作? 猜数字游戏过程: 用户自己输入一个数字A和程序中产生的一个数字B进行比较，如果A大于B则提示太大了，否则提示太小了，直到输入的数字A与产生的数字B相等，游戏结束，程序还需要设置一个猜的次数，如果超过次数则没猜中则游戏失败，否则成功。 猜数字游戏一、问题 程序中需要哪些变量? 用户要怎样输入? 怎样产生随机数字 ? 怎样使用循环和判断 ? 怎样创建对象 ? 它是用来干嘛的 ? 二、解决问题 使用Scanner对象获取玩家的输入，当然还需要System.in 定义变量input用于存储用户输入的数字，定义number存储计算机生成的随机数 为了控制循环和判断的逻辑还需要两个控制变量 running 和 guessed 为了控制玩家输入的次数，需要定义count计数器变量计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package top.coolcode;import java.util.Scanner; public class GuessNumber &#123; public static void main( String[] args ) &#123; //玩家需要输入，且输入的会是一个数字 Scanner sc = new Scanner(System.in); //程序运行所需要的要素,我怎么会想到需要这个,你是怎样想到的? boolean running = true; //控制游戏是否继续 boolean guessed = true; //控制是否要猜数字 //计算机帮我们生成的数字 int number = 0; //游戏玩家输入的数字 int input = 0; //记录猜的次数 int count = 1; //游戏是否能一直玩，靠的是这个running while(running) &#123; if(count&gt;3) &#123; System.out.println(&quot;三次机会已用完，游戏失败. 您可以继续游戏；退出输入-1&quot;); guessed = true; &#125; //判断是否要猜数字 if(guessed==true) &#123; System.out.println(&quot;计算机已经随机产生一个数，范围是0~20&quot;); System.out.println(&quot;您可以猜猜看, 退出输入 -1&quot;); number = getRandom(20); guessed = false;//设置为false,如果后续没有设置为true，就不会产生新的随机数 &#125; //如果上面的if分支进入了，那么说明随机数字已经产生 //游戏玩家输入的数字 input = sc.nextInt(); //判断用户输入 //如果用户输入的是-1表示结束游戏, 更改判断变量running为false,循环将终止 if(input == -1) &#123; running = false; &#125; else if(input &gt; number) &#123; System.out.println(&quot;输入的数字太大了,退出输入 -1&quot;); &#125; else if(input &lt; number) &#123; System.out.println(&quot;输入的数字太小了,退出输入 -1&quot;); &#125; else if(input == number)&#123; System.out.println(&quot;您猜对了，您可以继续游戏；退出输入 -1&quot;); guessed = true; //如果玩家没有输入-1则此变量设置为true,会继续产生随机数字 &#125; count++;//次数累加 &#125; &#125; /** * 定义一个函数用于产生随机数 * @param max * @return */ public static int getRandom(int max) &#123; return (int)(Math.random()*max) + 1; &#125;&#125; 简单的猜数字游戏，重要的是知道如何定义和使用程序运行过程中需要的要素(变量)，以及程序的执行流程。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字UI","slug":"Java/玩游戏学编程(2)-猜数字UI界面","date":"2022-07-17T01:19:56.085Z","updated":"2021-11-30T07:39:55.359Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(2)-猜数字UI界面/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(2)-%E7%8C%9C%E6%95%B0%E5%AD%97UI%E7%95%8C%E9%9D%A2/","excerpt":"","text":"游戏需要图形界面，虽然互联网时代Java FX 使用频率很小, 但是作为开发者，技多不压身，况且UI源码中有很多经典设计，是各类设计模式聚集地，可以让开发者加深对OOP、设计模式的理解。 如果把UI界面运用到游戏中去，既学到知识又增加趣味，岂不乐哉。 数字游戏界面一、问题 怎样使用JavaFX创建一个UI界面? 怎样创建一个按钮并添加到UI界面中? 怎样监听一个按钮的事件? 怎样使用线程开启一个异步任务? 在异步任务中绘图并添加到UI窗口 二、解决问题 要编写一个JavaFX界面，需要创建一个类并继承javafx.application.Application类(Java8中可以直接使用，更高版本的Java引入了模块化，需要手动引入), 并重写start方法： 代码中的Stage参数可以认为是一个UI窗口，英文翻译成“舞台”, 调用它的show方法显示这个窗口 12345678910package top.coolcode;import javafx.application.Application;public class GuessApp extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //显示“舞台”窗口 primaryStage.show(); &#125;&#125; 窗口创建好之后需要创建一些内容放到这个窗口中，这个内容我们称为Scene , 英文翻译成场景 可以独立创建一个函数，这个函数用来创建窗口界面中的内容 界面元素包含一个按钮Button, 并为这个按钮添加了一个事件处理函数,代码中使用了箭头函数 设置对象的属性通常会使用set开头的函数 123456789101112131415161718192021222324252627282930313233343536373839package top.coolcode;import javafx.application.Application;public class GuessApp extends Application &#123; //垂直盒子布局容器 private VBox root; //游戏中的地砖面板 private Pane tilePane; //使用Executors创建线程 private ScheduledExecutorService servicePool = Executors.newSingleThreadScheduledExecutor(); //存储所有数字框 的集合 private List&lt;TileView&gt; tileSequence = new ArrayList&lt;&gt;(); @Override public void start(Stage primaryStage) throws Exception &#123; //createContent()函数将会独立出来用于创建内容 Scene scene = new Scene(this.createContent()); //显示“舞台”窗口 primaryStage.show(); &#125; private Parent createContent() &#123; //使用垂直盒子进行布局，界面元素将会垂直放置在这个盒子容器中 // root是定义在类上的属性 this.root = new VBox(); //设置布局容器大小(宽，高) root.setPrefSize(1024, 500); //创建按钮对象 Button button = new Button(&quot;开始&quot;); //为按钮添加一个事件处理函数startGame(),也就是说当按下按钮后，这个函数就会被调用 button.setOnAction(e-&gt;startGame()); //创建一个面板 Pane pane = new Pane(); //获取这个垂直盒子容器并将面板和按钮添加到容器中 root.getChildren().addAll(pane, button); //返回这个垂直盒子容器，返回的内容将会被添加到舞台Stage return root; &#125;&#125; 编写按钮事件处理函数 在函数中会调用随机产生数字方格的函数populateGrid()，并将此函数返回的内容添加到VBox根容器 此函数中有一个计划任务，实际上使用的是Java中的线程池，同时还使用到了Java8中的Stream编程 123456789private void startGame() &#123; this.tilePane = this.populateGrid(); this.root.getChildren().set(0, tilePane); //6秒后执行线程,计划任务 this.servicePool.schedule(()-&gt;&#123; tilePane.getChildren().stream().map(n-&gt;(TileView)n) .forEach(TileView::hide);//此处是遍历tilePane面板上的每一个元素，并调用它的hide方法 &#125;, 6, TimeUnit.SECONDS);&#125; populateGrid函数实现, 用于随机绘制数字框，并添加到UI界面中 此函数的逻辑稍显复杂，主要使用到了Point2D类，产生9个数字框，并需要判断每个数字框不重合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private Pane populateGrid() &#123; Pane pane = new Pane(); pane.setPrefSize(1024, 500); Random random = new Random(); List&lt;Point2D&gt; usedPoints = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= 9; i++) &#123; int randomX = random.nextInt(1024/80); int randomY = random.nextInt(500/80); Point2D p = new Point2D(randomX, randomY); //判断集合usedPoints中是否包含了p,如果包含了则重新创建，并添加到usedPoints集合中 while(usedPoints.contains(p)) &#123; randomX = random.nextInt(1024/80); randomY = random.nextInt(500/80); p = new Point2D(randomX,randomY); &#125; usedPoints.add(p); //此类是自建类，用于创建一个数字框 TileView tile = new TileView(Integer.toString(i)); tile.setTranslateX(randomX * 80); tile.setTranslateY(randomY * 80); tile.setOnMouseClicked(e-&gt;&#123; if(tileSequence.isEmpty()) &#123; System.out.println(&quot;游戏已结束&quot;); return; &#125; TileView correctTile = tileSequence.remove(0); if(tile == correctTile) &#123; tile.show(); &#125; else &#123; tileSequence.clear(); System.out.println(&quot;失败：游戏结束&quot;); &#125; &#125;); pane.getChildren().add(tile); tileSequence.add(tile); &#125; return pane;&#125;private static class TileView extends StackPane &#123; private Text text; TileView(String content) &#123; Rectangle border = new Rectangle(80,80,null); border.setStroke(Color.BLUEVIOLET); border.setStrokeWidth(4); border.setStrokeType(StrokeType.INSIDE); text = new Text(content); text.setFont(Font.font(64)); getChildren().addAll(border,text); setPickOnBounds(true); &#125; void hide() &#123; text.setVisible(false); &#125; void show() &#123; text.setVisible(true); &#125;&#125; 最后运行程序 123public static void main(String[] args) &#123; launch(args);&#125; 此程序融合了线程、集合、FX UI界面、事件、Stream， 亦有很多英文单词","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字-JavaFX-UI","slug":"Java/玩游戏学编程(2)-猜数字-JavaFX-UI","date":"2022-07-17T01:19:56.081Z","updated":"2021-12-02T03:46:08.436Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(2)-猜数字-JavaFX-UI/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(2)-%E7%8C%9C%E6%95%B0%E5%AD%97-JavaFX-UI/","excerpt":"","text":"在之前那篇中涉及到很多知识点，其中之一就是JavaFX，JavaFX 是一个开源的下一代客户端应用平台，适用于基于Java构建的桌面、移动端和嵌入式系统。JavaFX类似于Java Swing；学习桌面UI也不是一无是处，WEB前端不也是一样的需要UI，而且WEB前端已经把桌面软件犯过的错误再重犯一遍，然后再把桌面软件的解决方案和设计方案再重新发明一遍, 学习使用JavaFX对后续再学前端或许能更快进入状态。 一、窗口 前面那篇代码中用到这些API： Application， Stage， Pane， VBox， Button 直接运行下面这段代码会出现一个窗口, Stage可翻译成舞台，调用show()方法就是显示这个舞台(窗口) 123456789public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; primaryStage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 二、控件 Button 12345678910111213141516171819public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //按钮控件 Button button = new Button(&quot;ok&quot;); //布局面板 Pane pane = new Pane(); //设置布局面板宽和高 pane.setPrefSize(900,500); //将控件添加到布局面板 pane.getChildren().add(button); //创建一个场景，并将布局面板添加到其中 Scene scene = new Scene(pane); primaryStage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 使用垂直布局容器VBox 1234567891011121314151617181920public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //垂直盒子容器 VBox vBox = new VBox(); vBox.setPrefSize(900, 500); Button button = new Button(&quot;ok&quot;); Button button1 = new Button(&quot;cancel&quot;); Pane pane = new Pane(); pane.setPrefSize(100,50); //将控件添加到VBox vBox.getChildren().addAll(pane,button,button1); Scene scene = new Scene(vBox); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 画图: 使用Rectangle类 为按钮添加事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; Pane pane = new Pane(); pane.setPrefSize(800, 300); Tile tile = new Tile(&quot;1&quot;); pane.getChildren().add(tile); //创建按钮并为按钮设置事件监听 Button button = new Button(&quot;点击隐藏矩形框&quot;); //此处使用了lambda表达式 button.setOnAction(e-&gt;&#123; tile.hide();//隐藏tile &#125;); Scene scene = new Scene(pane); primaryStage.setScene(scene); primaryStage.show(); &#125; private static class Tile extends StackPane &#123; //定义一个文本 private Text text; Tile(String content) &#123; //定义一个矩形 Rectangle rect = new Rectangle(80,80,null); //颜色 rect.setStroke(Color.AQUAMARINE); //宽度 rect.setStrokeWidth(4); //类型 rect.setStrokeType(StrokeType.INSIDE); //创建文本 text = new Text(content); //设置文本字体 text.setFont(Font.font(64)); //添加到当前布局面板 this.getChildren().addAll(rect, text); setPickOnBounds(true); &#125; void hide() &#123; text.setVisible(false); &#125; void show() &#123; text.setVisible(true); &#125; &#125;&#125; 如果想生成多个矩形，而且位置随机，可以使用Random类， 此类用于产生随机数。 123456789101112131415161718private Parent populateGrid() &#123; Pane pane = new Pane(); for (int i = 0; i &lt; 10; i++) &#123; TileView tile = new TileView(Integer.toString(i)); Random random = new Random(); int randomX = random.nextInt(1024/80); int randomY = random.nextInt(500/80); tile.setTranslateX(randomX * 80); tile.setTranslateY(randomY * 80); tile.setOnMouseClicked(e-&gt;&#123; &#125;); pane.getChildren().add(tile); &#125; return pane;&#125; 使用下面的代码测试populateGrid方法 12345678910111213141516public class Main extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; //===定义一个垂直盒子容器,populateGrid方法返回的Pane添加进去 VBox vBox = new VBox(); vBox.setPrefSize(1000, 500); //populateGrid函数将会返回一个Pane，Pane存放多个随机的矩形 vBox.getChildren().add( populateGrid()); Scene scene = new Scene(vBox); primaryStage.setScene(scene); primaryStage.show(); &#125;&#125; 以上代码简单介绍并使用JavaFX，对上一篇中的技术分解","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字-Stream","slug":"Java/玩游戏学编程(1)-猜数字-Stream","date":"2022-07-17T01:19:56.078Z","updated":"2022-07-17T03:39:58.166Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(1)-猜数字-Stream/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(1)-%E7%8C%9C%E6%95%B0%E5%AD%97-Stream/","excerpt":"","text":"在这一篇玩游戏学编程(1)-猜数字中出现了Stream相关技术， 先看看代码其中的一段代码： 12345678910this.tilePane = this.populateGrid(); this.root.getChildren().set(0, tilePane); //6秒后执行线程,计划任务this.servicePool.schedule( ()-&gt;&#123; tilePane.getChildren() .stream() .map(n-&gt;(Tile)n) .forEach(Tile::hide);&#125;, 6, TimeUnit.SECONDS); 代码中populateGrid()函数会返回一个Pane, 这个Pane中包含多个Tile, 每个Tile是一个矩形方框，其中还有一个数字, 那就意味着tilePane这个对象中有多个控件，我们可以通过循环或Stream遍历tilePane中的每一个控件; this.servicePool.schedule(lambda表达式）它可以传递一个Lambda表达式， 这里可以改成传统的自定义线程类对象，只不过现在可以用Lambda表达式的方式简写, 因为线程中的Runnable接口也只有一个抽象方法， 传统的代码写法如下: 12345678910111213//创建一个线程类，里边包含异步任务class ScheduleThread implements Runnable &#123; @Override public void run() &#123; ObservableList&lt;Node&gt; list = tilePane.getChildren(); for (int i = 0; i &lt; list.size(); i++) &#123; TileView tv = (TileView)list.get(i); tv.hide(); &#125; &#125;&#125;//创建一个异步任务，6秒后执行线程的run()方法this.servicePool.schedule(new ScheduleThread(), 6, TimeUnit.SECONDS); 遍历可以采用以下方式： 123456789//获取面板上的所有控件元素,返回的是一个集合ObservableList&lt;Node&gt; list = tilePane.getChildren();//遍历集合for (int i = 0; i &lt; list.size(); i++) &#123; //将集合中的每一个元素获取到，并强制转换成Tile对象 Tile tile = (TileView)list.get(i); //调用控件元素的hide方法 tile.hide();&#125; 以上这种方案很传统，代码繁杂，如果采用Lambda和Stream的方式，代码更简洁： 12345this.servicePool.schedule( ()-&gt;&#123; tilePane.getChildren().stream().map(n-&gt;(Tile)n) .forEach(Tile::hide); &#125;, 6, TimeUnit.SECONDS); 下面我们再来举个例子， 假如我们有一个ArrayList集合，其中存放了一些数据，那么遍历这种集合有两种方式 123456789101112131415List&lt;String&gt; fruitList = new ArrayList&lt;String&gt;();fruitList.add(&quot;苹果&quot;);fruitList.add(&quot;香蕉&quot;);fruitList.add(&quot;西瓜&quot;);//第一种遍历方式，每获取一个元素直接输出, 此种方式属于外部迭代for (int i = 0; i &lt; fruitList.size(); i++) &#123; String fruit = fruitList.get(i); System.out.println(fruit);&#125;//另一种方式，采用forEach,其实也是外部迭代，只是采用了Lambda表达式fruitList.forEach(item-&gt;&#123; System.out.println(item); &#125;);//如果仅仅是输出集合中的每一个元素，还可以使用更简单的写法fruitList.forEach(System.out::println); 我们可以使用Stream对这个集合进行过滤、筛选、切片、映射等操作, 这些操作称为对集合的中间操作，最后可以对Stream进行关闭操作称为终端操作， 比如我们使用java.util.stream.Stream接口中的map方法： 123fruitList.stream().map(item-&gt;&#123; return &quot;&amp;&quot;+item+&quot;&amp;&quot;; &#125;).collect(Collectors.toList()).forEach(System.out::println); 这段代码的意思是将迭代(遍历)集合中的每一个元素，迭代过程中每遇到一个元素会将其传递给Lambda表达式对应的方法，由方法处理完成之后返回，此处是将每个元素的前后添加一个&amp;符号，最后处理完所有元素后再将其转换为List集合 (collect 终端操作), 那么对于猜数字游戏中的如下代码意思是通过Stream接口的map方法，过程是将每一个元素转换成Tile对象，然后通过forEach迭代每一个元素并调用它的hide方法 12tilePane.getChildren().stream().map(n-&gt;(Tile)n) .forEach(Tile::hide); 初学者如果不理解Stream，只能通过大量的练习去熟练，如果能有函数式编程语言基础便更容易理解","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"玩游戏学编程(1)-猜数字-Lambda","slug":"Java/玩游戏学编程(1)-猜数字-Lambda和Stream","date":"2022-07-17T01:19:56.075Z","updated":"2022-07-17T02:43:23.633Z","comments":true,"path":"2022/07/17/Java/玩游戏学编程(1)-猜数字-Lambda和Stream/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/Java/%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%AD%A6%E7%BC%96%E7%A8%8B(1)-%E7%8C%9C%E6%95%B0%E5%AD%97-Lambda%E5%92%8CStream/","excerpt":"","text":"概念在这一篇中出现了Lambda表达式和Stream玩游戏学编程(1)-猜数字， 它们在Java应用开发中现已成为常用的开发技术， Lambda表达式这玩艺在函数式编程语言如Ruby、JavaScript、Python中早已存在，Java只是把他们学了过来。你可以把Lambda表达式看作是一种匿名功能，也就是没有名称的方法,可以认为lambda它是一块代码，我们在使用时可以将这块代码传递出去，这样它后续可以执行一次或多次，如果你了解过匿名类，那么对Lambda的写法就不会感到太生涩。 Java中没有函数类型，如果要实现Lambda表达式就得将函数表达为对象，也就是实现了特定接口的类的实例，当然你先得对面向对象中的接口以及实现有一些经验。 简单的使用 任务：对一个数组进行排序，调用数组排序函数Arrays.sort(), 使用Lambda表达式自定义排序方式 默认排序方式 12345int[] a = &#123;3,21,4,99,32,87,9&#125;;Arrays.sort(a);for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+&quot;,&quot;);&#125; 输出排序结果：3,4,9,21,32,87,99, 如果我们需要控制比较结果，比如说从大到小排列，就必须自定义比较逻辑，这个比较逻辑需要实现一个接口Comparator, 这个接口称为函数式接口,而且这个接口只有一个抽象方法compare, 代码如下: 1234567891011private static class ComparatorNumber implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer m, Integer n) &#123; if(m&gt;n) &#123; return -1; &#125; return 0; &#125;&#125; 12345678Integer[] ary = &#123;3,21,4,99,32,87,9&#125;;//创建比较对象ComparatorNumber comparatorNumber = new ComparatorNumber();//第二个参数为自定义比较对象Arrays.sort(ary, comparatorNumber);for (int i = 0; i &lt; ary.length; i++) &#123; System.out.print(ary[i]+&quot;,&quot;);&#125; ComparatorNumber类的compare方法为比较方式的实现 使用Lambda表达式 上面的代码可以直接换成lambda表达式的方式，更简洁, 可以把它称为箭头函数，具体的语法如下: 1(参数1, 参数2) -&gt; &#123; 函数实现 &#125; 如果只有一个参数，语法还可以是下面这样: 1形参1 -&gt; &#123;函数实现&#125; 如果没有函数的实现只有一个返回代码，还可以用下面这种写法: 1形参1 -&gt; 返回的变量 比较函数的改造如下, 上面创建的比较类就不需要了 : 123456Arrays.sort(ary, (m,n)-&gt;&#123; if(m&gt;n) &#123; return -1; &#125; return 0;&#125;); 如果希望一个接口成为函数式接口，只需要这个接口中仅有一个抽象方法即可 如果对sort方法的第二个参数已有实现的代码，我们也可以直接拿过来使用, 下面的代码就是直接使用了Integer的比较方法compareTo,只是它的比较方式是从小到大，使用方法如下: 1Arrays.sort(ary,Integer::compareTo); Java 类库中有很多这样的接口，比如多线程中的Runnable接口, 那么对于玩游戏学编程(1)-猜数字这篇中的如下代码应该就能理解了，按钮的事件监听器对象本身也需要实现一个接口EventHandler, 并且此接口仅有一个抽象方法，此时可以使用Lambda表达式 123456789101112private static class ButtonLis implements EventHandler&lt;ActionEvent&gt; &#123; @Override public void handle(ActionEvent event) &#123; &#125;&#125;button.setOnAction(new ButtonLis());//忽略上面的代码，直接使用Lambda表达式Button button = new Button(&quot;开始&quot;);button.setOnAction(e-&gt;startGame());//开始按钮事件,startGame()是具体的实现","categories":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"一个简单的前端机试题","slug":"JavaScript/JavaScript-Interview-1","date":"2022-07-17T01:19:56.056Z","updated":"2022-07-17T03:30:34.935Z","comments":true,"path":"2022/07/17/JavaScript/JavaScript-Interview-1/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/JavaScript-Interview-1/","excerpt":"","text":"一个简单的前端机试题，使用原生JavaScript或是JQuery又或是Vue，如果能快速搞定，用什么无所谓啦 效果图 还是有几点要求的 点击固定标签可以修改选中状态，选中方式为多选 自定义输入框可输入10个字以内的标签（限制中文） 点击确认会在标签后面新增一个自定义名称的标签，自定义标签数量超过5个之后，输入框和确认按钮置灰，不可点击 点击确认时，需要对当前自定义标签的名称进行去重，如果标签重复，需要在确认按钮后面用红色的文字提示“该标签已重复” 自定义的标签右上角会有个删除的按钮，点击删除按钮会删除该自定义标签","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://zhsunbeam.github.io/tags/HTML/"}]},{"title":"玩游戏学前端-贪吃蛇","slug":"JavaScript/snake","date":"2022-07-17T01:19:56.024Z","updated":"2022-07-17T03:22:52.563Z","comments":true,"path":"2022/07/17/JavaScript/snake/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake/","excerpt":"","text":"在游戏项目中学JavaScript WEB前端基础技术包含HTML5/CSS3/JavaScript, 当然除了基础技术前端还有框架如React,Vue等, 其中相对难一点的便是JavaScript和CSS3，CSS3学起来开心多了, JavaScript编程语言可没那么有趣，如果用它来实现游戏，我想趣味性要超越CSS3, 俗话说：兴趣是最好的老师；下面我们一步步来实现这个小游戏，在开发过程中去学习JavaScript语言和CSS3的关键技术要点。效果如下图所示 贪吃蛇 贪吃蛇游戏 1. HTML5和CSS3设计游戏界面 HTML页面组成，常用标签和meta 准确使用HTML标签div, 标签中的基本属性 为HTML标签添加样式 CSS3样式编写，标签选择器，ID选择器，类选择器 CSS3中的常用单位 px,rpx,em,rem,vh,vw,vmin,vmax CSS3边框和颜色 CSS3 Grid网格布局 2. HTML与Javascript ES5和ES6的基本认知 在HTML中添加Javascript脚本支持 Javascript语言基础: 变量、程序逻辑、函数、对象 Javascript的模块化 3. Javascript操作HTML元素 - DOM 使用Javascript选择HTML元素 Javascript动画 Javascript创建HTML元素 Javascript设置HTML元素样式 Javascript定义游戏核心逻辑 4. 绘制Snake Javascript数组和DOM操作 创建Snake Head，定义速度常量 移动Snake Head 使用Javascript事件控制Snake方向 创建Snake Body并绘制蛇的身体 6. 绘制Food Javascript数组和DOM操作 使用Javascript DOM创建Food Javascript创建随机数 根据随机数位置显示Food 7. Snake和Food Snake吃Food，Snake增长逻辑 7. 游戏结束 Snake移动范围边界判断 游戏结束判断","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-Grid布局","slug":"JavaScript/snake-grid","date":"2022-07-17T01:19:56.022Z","updated":"2022-07-17T03:23:22.864Z","comments":true,"path":"2022/07/17/JavaScript/snake-grid/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-grid/","excerpt":"","text":"CSS Grid网格布局 在贪吃蛇游戏中，我们使用了CSS中的Grid网格布局，如果不用Grid，你可以使用Canvas绘图。其实在其它编程语言的UI设计中，早已有此类布局方案,比如Java中的GridLayout，感觉CSS把后端语言的UI设计又重新走一遍，而且进展还比较慢 , 多年以前我们还只能使用position,float和各种骇客技术实现布局,直至出现Flex、Grid才真正意义上的解脱； 网格布局示例图 HTML结构 需要将想要控制的元素包装在父容器DIV中 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;div4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 让我们为div添加一些样式，这样就可以轻松地区分不同盒子,这里使用了 display:grid，也就是网格布局 123456789101112.wrapper &gt; div &#123; background-color: orange; border: 1px black solid;&#125; .wrapper &gt; div:nth-child(odd) &#123; background-color: indianred;&#125; .wrapper&#123; display: grid&#125; Grid-template-columns 和 Grid-template-rows grid-template-columns 规则对于grid网格布局，我们首先需要了解的是 grid-template-columns 和 grid-template-rows 这两条规则。这两条规则控制了网格的形状。这些规则的值可以是长度、百分比或网格中空闲空间的一部分。还可以将它们设置为auto，这样做将会填充div盒子的剩余的空间。看例子: 1234.wrapper&#123; display: grid; grid-template-columns: 100px 100px 100px&#125; 上面代码片断中我们设置了三列，每列100px, 但是wrapper下有四个div,所以会有一个div换行显示， display的值还可以设置为inline-grid 修改一下中间设置为auto 1234.wrapper&#123; display: grid; grid-template-columns: 100px auto 100px&#125; 上面代码中，中间值使用了auto, 那么中间那个div将填充所有剩余部分 也可以使用fr, 网格布局提供了fr(fraction片段的意思)，它用于表示比例关系，如果列宽度都为1fr , 那么将平分此行 1234.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr;&#125; 上面代码中将一行分为四列，每列宽度一样 修改一下值 1234.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 3fr 1fr;&#125; 可以看出第二列是第一列的2倍，第三列的大小是前面二列的和; 试着修改最后一列的大小 grid-template-columns 和 grid-template-rows 规则12345.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 50px 50px;&#125; 上面定义二行二列，每一行的高度都为50px, 如果将第一个50px改成其它值如30px, 那么第一行高度将为30px 12345.wrapper &#123; display: grid; grid-template-columns: 100px 20px 250px; grid-template-rows: 150px 40px;&#125; 上面定义二行三列，第一行高150px, 第二行高40px, 前面3个div成为一行中三列，最后一个div单独一行 grid-template 重复规则： Repeat如果你的网格布局中有一个重复的元素，你可以使用repeat并告诉它重复多少次相同的元素。例如，假设你有12个元素，你想让它们以相同的宽度水平放置。您可以在grid-template-column使用repeat(12, 1fr)。 也可以像下面这样 1234.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr 5fr 10fr);&#125; 上面代码中重复4个div元素，1，2，3是第一部分，分别为1fr, 5fr, 10fr; 后续依此类推 Grid-auto-columns 和 Grid-auto-rows 规则此规则帮助你设置网格单元格的宽度和高度。如果不设置此规则，网格的行和列将根据内容展开。 12345.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 100px;&#125; 上面代码重复4个元素，因为总共有12个元素，所以拆分成了3行，每行100px高 12345.wrapper &#123; display: grid; grid-template-columns: repeat(6, 1fr); grid-auto-rows: 100px;&#125; 上面代码重复6个元素，因为总共有12个元素，所以拆分成了2行，每行100px高 12345.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 20px 40px 60px;&#125; minmax() 函数网格自动规则的一个很好的特性是minmax函数。只需将最小值设置为第一个参数，将最大值设置为第二个参数。如果将第二个参数设置为auto，则会得到响应式单元格大小。 12345.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: minmax(50px, auto) &#125; 以上两个结果是CSS相同，div中内容不同的情况 Grid-gap 顾名思义，该规则在网格单元格之间创建了一个间隙(gap)。如果你使用grid-gap: 5px，你会在每个单元格之间得到5px的间隙。或者，只能设置行或列间隙，分别为grid-row-gap: 5px和grid-column-gap: 5px。 123456.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: minmax(50px, auto); grid-gap: 5px; &#125; 子div元素规则 到目前为止，我们只关注网格的形状和在网格中流动的项。现在我们将学习如何单独控制每一项。 为了定位每一项，我们使用网格线作为参考。下面是2x4网格的行和列，分别用黑色和橙色表示。 使用带有行号的 grid-column 和 grid-row 规则来定位元素。 例如，如果我们为第一个子div设置grid-column: 1/3，它将使用网格中的前两个单元格, 也就是第1格到第3格，但不包含第3格, 这种做法类似于在Excel中的列合并。 grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 123456789.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 100px; grid-gap: 5px; &#125;.div1&#123; grid-column: 1/3;&#125; 1234.div1 &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 1234567891011.div1 &#123; grid-column: 1 / 3; /*占用 1~2 列, 也就是跨列*/ grid-row: 1 / 2;&#125;/* 等同于 */.div1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 再看下面示例，div1元素跨列和行 1234.div1&#123; grid-column: 1/3; grid-row: 1/3;&#125; 也可以使用grid-arge 123.div1&#123; grid-area: 2/2/3/4;&#125; Grid-area 和 grid-template-areas 下面的示例稍复杂一点 12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;header&quot;&gt;页头&lt;/div&gt; &lt;div class=&quot;leftCol&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;rightCol&quot;&gt;右侧&lt;/div&gt; &lt;div class=&quot;midTop&quot;&gt;中间上方&lt;/div&gt; &lt;div class=&quot;midBottom&quot;&gt;中间下方&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;页脚&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041.header&#123; grid-area: header; background-color: LightSeaGreen ; &#125; .leftCol&#123; grid-area: leftCol; background-color: orange; &#125; .rightCol&#123; grid-area: rightCol; background-color: lightblue; &#125; .midTop&#123; grid-area: midTop; background-color: lightgrey; &#125; .midBottom&#123; grid-area: midBottom; background-color: pink; &#125; .footer&#123; grid-area: footer; background-color: lightgreen; &#125;.wrapper &#123; display: grid; grid-template-columns: 1fr 4fr 4fr 1fr; grid-template-rows: 50px 100px 100px 30px; grid-template-areas: &quot;header header header header&quot; &quot;leftCol midTop midTop rightCol&quot; &quot;leftCol midBottom midBottom rightCol&quot; &quot;footer footer footer footer&quot;; grid-gap: 5px; &#125; 布局结果 如果想让页脚只取两列并居中，那么我只需在网格模板区域中用点(.)替换页脚的第一个和最后一个。 1234567891011.wrapper &#123; display: grid; grid-template-columns: 1fr 4fr 4fr 1fr; grid-template-rows: 50px 100px 100px 30px; grid-template-areas: &quot;header header header header&quot; &quot;leftCol midTop midTop rightCol&quot; &quot;leftCol midBottom midBottom rightCol&quot; &quot;. footer footer .&quot;; grid-gap: 5px; &#125; 你需要grid Grid 布局还有很多其它属性，可以参考官方文档， 有了上述基础，我们就可以画出贪吃蛇游戏的界面了，马上为你呈现使用Grid有多么简单","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-ES6模块化","slug":"JavaScript/snake-es6module","date":"2022-07-17T01:19:55.830Z","updated":"2022-07-17T03:23:15.072Z","comments":true,"path":"2022/07/17/JavaScript/snake-es6module/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-es6module/","excerpt":"","text":"贪吃蛇-ES6模块化 在后续内容中，我们逐渐在游戏面板上绘制蛇和食物，将会涉及到 javascript DOM技术、ES6中的模块化、箭头函数等知识，所以我们先简单地把要用到的知识点了解和应用。如果需要全面了解，请移步相关官方文档。或者与我私聊，嘿嘿！ 游戏核心逻辑模块化: 使用ES6模块化 现代浏览器基本上都支持ES6模块化(有关ES6的基础知识，可参考阮一峰老师ECMAScript 6入门), 首先我们创建一个main.js文件，这个文件是游戏的入口，只需要在HTML页面上引入main.js，main.js文件内的逻辑先不管，可以先创建一个空文件。关键代码如下: 1&lt;script src=&quot;main.js&quot; defer type=&quot;module&quot; &gt;&lt;/script&gt; defer(延期，推迟) defer属性的意思是HTML页面渲染完成,同时页面中其它脚本也执行完成后脚本文件才会执行, 如果有多个脚本文件都声明了defer, 这些脚本的加载顺序会按照它们在HTML页面上出现的顺序 async(异步) 声明了这个属性的JS脚本一旦下载完成就会立即执行, 如果多个脚本文件都声明了async, 那么它并不能保证按出现的顺序加载 type=”module” 表示让浏览器知晓这是一个ES6模块 模块化在Java中有import，nodejs中也有require, python中有import, 在ES6之前，我在前端开发中会使用CommonJS、requireJS、seaJS等进行模块化, Javascript终于不用第三方插件也可以模块化了，意外地开心，但必须强调一点，使用它还需要浏览器支持才行。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;贪吃蛇游戏&lt;/title&gt; &lt;style&gt; body &#123; height: 100vh; width: 100vw; display: flex; flex-direction: row; justify-content: left; align-items: center; margin: 0; background-color: black; &#125; #game-board &#123; background-color: rgb(250, 245, 245); width: 100vmin; height: 100vmin; display: grid; grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr); &#125; #settings &#123; display: grid; &#125; &lt;/style&gt; &lt;script src=&quot;main.js&quot; defer type=&quot;module&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;game-board&quot;&gt; &lt;/div&gt; &lt;div id=&quot;settings&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下面创建一个snake.js蛇模块和food.js食物模块， 暂时仅在里边定义update和draw函数, update函数实现蛇的变化逻辑， 比如蛇的移动方向以及它的长度变化; draw函数实现蛇的绘制。 food.js类似 snake.js 1234567function update() &#123; console.log(&#x27;更新蛇&#x27;)&#125;function draw() &#123; console.log(&#x27;绘制蛇&#x27;)&#125;export &#123;update, draw&#125; food.js 1234567function update() &#123; console.log(&#x27;更新食物&#x27;)&#125;function draw() &#123; console.log(&#x27;绘制食物&#x27;)&#125;export &#123;update, draw&#125; 上面两个文件都用到了export关键词，用于导出模块中的内容 main.js实现，会用到之前文章中讲到的window.requestAnimationFrame,游戏界面需要不断更新并重绘 , 先使用import 导入snake.js, food.js, 这两个文件和main.js是在同一个目录下， 导入时使用 as 给出一个别名以便在main.js中使用 123456789101112131415161718192021222324//引入 snake.js 和 food.js模块内容 import &#123;update as updateSnake, draw as drawSnake&#125; from &#x27;./snake.js&#x27;import &#123;update as updateFood, draw as drawFood&#125; from &#x27;./food.js&#x27;function main(currentTime) &#123; //再次请求动画帧 window.requestAnimationFrame(main) //调用本模块中的update和draw函数 update() draw()&#125;//请求动画帧window.requestAnimationFrame(main)//因为有蛇和食物需要更新，所以定义了update函数，在函数内部调用另外两个模块的函数function update() &#123; updateSnake() updateFood()&#125;//因为有蛇和食物需要绘制，所以定义了draw函数，在函数内部调用另外两个模块的函数function draw() &#123; drawSnake() drawFood()&#125; 可以将这些代码整合到vscode开发工具中，再运行index.html文件，在浏览器控制台查看效果。 下一篇我们看如何使用DOM绘制蛇和食物。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-使用DOM画蛇","slug":"JavaScript/snake-dom","date":"2022-07-17T01:19:55.828Z","updated":"2022-07-17T03:23:08.867Z","comments":true,"path":"2022/07/17/JavaScript/snake-dom/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-dom/","excerpt":"","text":"使用DOM画蛇 上一篇中我们将整个游戏划分了模块，主要有main.js, snake.js, food.js三个模块，然后在main模块中使用了window.requestAnimationFrame()请求动画帧函数, 通过这个函数不断重复调用update()和draw()函数，这两个函数用于更新界面和重绘游戏中的蛇和食物, 到现在为止并没有实现这两个函数的具体功能，在这一篇中我们将使用JavaScript DOM技术把蛇画出来。 JavaScript DOM DOM 全称文档对象模型，在前端是将WEB页面和JavaScript脚本语言连接起来，提供了一套API（应用程序编程接口）用于操作HTML元素、处理事件等，在贪吃蛇游戏中我们需要用到几个DOM API来创建蛇和食物： 怎样获取HTML元素? 12document.getElementById();document.querySelector(); 怎样创建HTML元素? 1document.createElement() 怎样修改元素的样式属性？ 123元素.style = ...元素.className = ...元素.classList.add(...) 怎样添加元素? 1元素.appendChild(其它元素) JavaScript中如何定义数组? 1const snakeBody = [ 数组内容 ] 绘制蛇身体和头部 HTML代码就不重复了，先在main.js文件中获取网页中id为game-board的元素， 然后再绘制蛇或食物的时候需要传递这个HTML元素给drawSnake方法， 关键代码如下： 获取HTML元素的关键代码 123let gameBoard = document.getElementById(&#x27;game-board&#x27;)//或者let gameBoard = document.querySelector(&#x27;#game-board&#x27;) 调用绘制蛇和食物的关键代码 12drawSnake(gameBoard)drawFood(gameBoard) 完整代码如下: 1234567891011121314151617181920212223242526272829//引入 snake.js 和 food.js模块内容 import &#123;update as updateSnake, draw as drawSnake&#125; from &#x27;./snake.js&#x27;import &#123;update as updateFood, draw as drawFood&#125; from &#x27;./food.js&#x27;/* 通过getElementById获取元素 */let gameBoard = document.getElementById(&#x27;game-board&#x27;)function main(currentTime) &#123; //再次请求动画帧 window.requestAnimationFrame(main) //调用本模块中的update和draw函数 update() draw()&#125;//请求动画帧window.requestAnimationFrame(main)//因为有蛇和食物需要更新，所以定义了update函数，在函数内部调用另外两个模块的函数function update() &#123; updateSnake() updateFood()&#125;//因为有蛇和食物需要绘制，所以定义了draw函数，在函数内部调用另外两个模块的函数function draw() &#123; //画蛇 在game.js模块中drawSnake和drawFood 是一个别名 drawSnake(gameBoard) //画食物 drawFood(gameBoard)&#125; 下面将会在snake.js模块中实现draw方法 在snake.js模块中需要定义蛇，我们使用一个数组来表示，数组中的每一个元素代表蛇的每一个部分的坐标位置，包括x和y, 因为game-board采用的是网格布局，所以每一项（也就是单元格) 都有固定的坐标, 这个坐标(x,y)不能为0，也不能超过在CSS中设定的网格数(网页中设定的是50) : 123456789101112131415161718#game-board &#123; background-color: rgb(250, 245, 245); width: 100vmin; height: 100vmin; display: grid; grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr);&#125;/* 蛇头样式, 使用图片，来源 https://www.iconfont.cn/ */.snake-head &#123; background-image: url(&#x27;./images/head1.png&#x27;); background-size: cover;&#125;/* 蛇身子样式 */.snake-body &#123; background-color: hsl(200,100%,50%); border-radius: 80%;&#125; 蛇用一个对象数组表示，数组中的每个对象表示蛇的一部分 123const snakeBody = [ &#123;x : 2, y : 2&#125;,] 在draw函数中根据snakeBody数组的大小创建多个div元素，用于显示蛇，蛇的长度在后面的游戏过程中会要增加，所以这个snakeBody数组会动态改变大小, 创建div元素并设定它的样式代码如下: 12345678910111213//创建一个div元素const snakeElement = document.createElement(&#x27;div&#x27;)//设置div元素的样式, 使用style//行位置snakeElement.style.gridRowStart = snakeBody[0].x//列位置snakeElement.style.gridColumnStart = snakeBody[0].y//背景颜色snakeElement.style.backgroundColor = &#x27;hsl(200,100%,50%)&#x27;//边框snakeElement.style.border = &#x27;.25vmin solid black&#x27;//将蛇添加到gameBoard元素中gameBoard.appendChild(snakeElement) 通过循环画蛇，一开始仅有一个蛇头，可以自行在snakeBody中添加对象并查看效果 123456789101112131415for(var i=0;i&lt;=snakeBody.length;i++) &#123; //创建一个div元素 const snakeElement = document.createElement(&#x27;div&#x27;) //设置div元素的样式, 使用style //行位置 snakeElement.style.gridRowStart = snakeBody[i].x //列位置 snakeElement.style.gridColumnStart = snakeBody[i].y //背景颜色 snakeElement.style.backgroundColor = &#x27;hsl(200,100%,50%)&#x27; //边框 snakeElement.style.border = &#x27;.25vmin solid black&#x27; //将蛇添加到gameBoard元素中 gameBoard.appendChild(snakeElement)&#125; 实现的代码删除和背景颜色和边框，使用classList.add方法添加样式，snake.js完整代码如下 12345678910111213141516171819202122232425262728function update() &#123; console.log(&#x27;更新蛇&#x27;)&#125;function draw(gameBoard) &#123; for(var i=0;i&lt;=snakeBody.length;i++) &#123; //创建一个div元素 const snakeElement = document.createElement(&#x27;div&#x27;) //设置div元素的样式, 使用style //行位置 snakeElement.style.gridRowStart = snakeBody[i].x //列位置 snakeElement.style.gridColumnStart = snakeBody[i].y if(index == 0) &#123; //为蛇头 添加snake-head样式类 snakeElement.classList.add(&#x27;snake-head&#x27;) //蛇头随着按下不同的方向键进行旋转，getHeadDirection函数后面再实现，此行先注释 //snakeElement.style.transform = &#x27;rotate(&#x27;+getHeadDirection()+&quot;)&quot; &#125; else &#123; //为蛇身体添加样式类 snakeElement.classList.add(&#x27;snake-body&#x27;) &#125; //将蛇添加到gameBoard元素中 gameBoard.appendChild(snakeElement) &#125;&#125;export &#123;update, draw&#125; 画食物的函数在这里就没有贴出代码，可以自己参考画蛇的方法完成食物的绘制","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"玩游戏学前端-贪吃蛇-游戏界面","slug":"JavaScript/snake-board","date":"2022-07-17T01:19:55.826Z","updated":"2022-07-17T03:22:24.772Z","comments":true,"path":"2022/07/17/JavaScript/snake-board/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/snake-board/","excerpt":"","text":"贪吃蛇-游戏界面 在编写界面之前，有一些前置知识必须要理解并能熟练使用，比如flex和grid布局， vh、vw、 vmin、 vmax、em、rem、px单位; 有了这些知识，编写游戏界面将变得非常简单，下面我们一步步实现。 HTML设计 只需一个div元素，给它一个id 123&lt;body&gt; &lt;div id=&quot;game-board&quot;&gt;&lt;/div&gt;&lt;/body&gt; body样式 我们需要定义高度和宽度，对整个body元素采用flex布局，主要目的是让其内容居中，并给一些基础样式美化一下；会使用到 display, justify-content, align-items 这些和flex布局相关， vh,vw单位也将使用到 123456789body &#123; height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; margin: 0; background-color: black;&#125; vw、vh、vmin和vmax是CSS3中的视窗单位，也是相对单位。它们的大小都是由视窗大小来决定的，单位1，表示视窗的1%；vw：视窗宽度的百分比， vh：视窗高度的百分比， vmin：当前较小的vw和vh， vmax：当前较大的vw和vh 视窗是指浏览器可视区域的宽和高， 1vm 表示 1%浏览器可视区域的宽，100vm表示整个可视频区域的宽 div游戏面板样式 我们使用到了id选择器 #game-board, 定义了背景颜色，以及宽度和高度， 同时这个游戏界面我们使用网格布局，目的是把蛇的头和身子以及食物都用格子表示 12345678#game-board &#123; background-color: #CCC; width: 100vmin; height: 100vmin; display: grid; grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr);&#125; 使用了行列均为50格子的网格布局 grid-template-rows: repeat(50, 1fr); grid-template-columns: repeat(50, 1fr); 蛇和食物样式 123456789.snake &#123; border: .20vmin solid black; background-color: hsl(200, 100%, 50%);&#125;.food &#123; border: .20vmin solid black; background-color: hsl(50, 100%, 50%);&#125; 就这么简单, 蛇和食物都需要使用Javascript动态创建，后续就是Javascript编码了","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"JOOQ&DSL","slug":"JOOQ/JOOQ","date":"2022-07-17T01:19:55.806Z","updated":"2021-11-26T08:44:57.053Z","comments":true,"path":"2022/07/17/JOOQ/JOOQ/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JOOQ/JOOQ/","excerpt":"","text":"​ 为了更”懒”一点，程序员们发明了各种ORM框架，从繁琐的SQL中解放了出来，但产生的副作用便是需要学习一套的对象和关系映射的API，再加上一堆的XML配置或是感觉不那么舒服的注解。 ​ 相比开发中主流的ORM开发框架Hibernate、MyBatis/MyBatisPlus， JOOQ(Java Object Oriented Query), 是一个不那么广泛应用的ORM&amp;DSL(Domain Specific Language)框架。 ​ 使用它必定有强大的理由，也就是说JOOQ解决了哪些开发中的哪些痛点，长时间以来我们使用Hibernate/MyBatis来服务开发中的数据查询、持久化等功能，虽然都能在一定程度上提升生产率，让开发人员专注于业务，但在实践中复杂且并不易维护的XML配置让人抓狂，复杂的判断逻辑操作几乎需要纯手工打造。那么使用JOOQ的理由便正如它官网(jooq.org)上的那句: Our customers spend most time on their business-logic.Because jOOQ takes care of all their Java/SQL infrastructure problems. JOOQ的优点： Database First：数据库优先，和MyBatis一样提供灵活的不隐藏SQL的方式，用Java代码的风格编写SQL语句 Typesafe SQL：将SQL建模为内部DSL，并使用Java编译器编译SQL语法、元数据和数据类型 Code Generation：它从数据库元数据生成Java类。当代码与模式不同步时，Java编译器会告诉你 Active Records：允许你直接在ActiveRecords上执行CRUD和POJO映射，这些ActiveRecords也是由代码生成器生成的 Multi-Tenancy：允许你在运行时配置数据库模式和表覆盖，还支持行级安全性 Standardisation：将常见的SQL表达式转换为数据库中最接近的匹配。编写适用于所有数据库的SQL Query Lifecycle：让你的程序与它的SQL生成生命周期挂钩，用于日志记录、事务处理、ID生成、SQL转换等 Procedures：允许你将存储的函数调用嵌入到SQL语句中 jOOQ的缺点： 对开源数据库免费，对商业数据库收费 一系列的总结记录jOOQ使用方法，以便查询","categories":[{"name":"JOOQ","slug":"JOOQ","permalink":"https://zhsunbeam.github.io/categories/JOOQ/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"ORM框架","slug":"ORM框架","permalink":"https://zhsunbeam.github.io/tags/ORM%E6%A1%86%E6%9E%B6/"}]},{"title":"H5“面子”-盒子与边框","slug":"H5CSS3/H5-box-border","date":"2022-07-17T01:19:55.804Z","updated":"2021-12-09T05:10:47.947Z","comments":true,"path":"2022/07/17/H5CSS3/H5-box-border/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/H5CSS3/H5-box-border/","excerpt":"","text":"​ 想成为一名更赚钱的WEB开发工程师，当然没问题，H5和CSS3了解一下，噢，可不能简单了解，技术上你需要深入理解盒子模型、JavaScript编程逻辑、HTTP协议、IP和域名等; 设计上你需要搞定颜色搭配、字体风格、各种类型的图片处理、整体布局设计等等; 如果仅仅是制作几个只有你自己看的页面，那就简单了；可多数时候我们是要将成果拿给客户看，怎么办？现成的UI组件救开发人员于水火：Bootstrap、ElementUI、weui等等，但是学习这些UI组件库成本也不低(主要是好多英文单词)，如果对Java中的awt/Swing、JavaFX, C++中的MFC界面库、Qt等客户端界面设计有过经验，学习起来自然顺风顺水，毕竟这些优秀的设计方法在前端又会要从头来一遍； H5设计页面 HTML5共有一百多个标签，需要都记住吗？No，实际上常用的标签也就那么十几二十个， 标签很容易使用，基本无门槛；难点在于CSS的设计，特别是排版，当然现在已有更方便的flex、grid, 那么还有什么问题呢? 英语单词比较多,单词量还可以的朋友可以直接忽略这个问题，另外就是你需要将制作的页面发布到服务器，至少不是只有自己欣赏。 使用非常频繁的标签, 记住它们的基本属性 div, span, ul, li, table, a, p, form, input(type=text|checkbox|radio|password), button, select/option, textarea header, footer, section, article, aside, details, nav 设计页面时常用的样式 定位： position, display, float, clear 背景： background-color, background-image, background-repeat, background-position,background-size, background-attachment, background 字体：font-family, font-size, font-style, font-weight, font-variant, font 单位： px, rpx, em, rem 边框： border, border-width, border-style, border-color 盒子模型 样式 border, margin, padding 其它常见单词 content, left, right, top, bottom w3c.org 官网盒子模型图 盒子与边框、内容有一个观念必须建立，那就是不管你的写的元素是什么，它都是一个盒子，无论是文本还是按钮，div或是span，对CSS来说每一个元素都是盒子， 每个盒子都有文本以及边框等，我们需要知道这些不同部分之间的关系，同时也要明白盒子和盒子之间的关系如何定义 123456789101112131415161718192021* &#123; padding: 0; margin: 0; font-size: 40px;&#125;.box-one &#123; background-color: #EB5757; border: 0px solid #9B51E0; padding: 0px; margin: 0px;&#125;.box-two &#123; background-color: aqua; border: 0px solid seagreen; padding: 0px; margin: 0px;&#125;&lt;body&gt; &lt;div class=&quot;box-one&quot;&gt;One&lt;/div&gt; &lt;div class=&quot;box-two&quot;&gt;Two&lt;/div&gt;&lt;/body&gt; 效果如下图所示， 一个盒子实际所占有的宽度和高度是由 “内容(content)+内边距(padding)+边框(border)+外边距(margin)”组成, 对任何盒子都可以分别设定4条边各自的border、padding、margin, 注意外部元素body也是一个盒子 我们可以修改盒子的border以及padding和margin 123456789101112.box-one &#123; background-color: #EB5757; border: 20px solid #9B51E0; padding: 20px; margin: 30px;&#125;.box-two &#123; background-color: aqua; border: 20px solid seagreen; padding: 20px; margin: 30px;&#125; 再看看计算后的盒子模型， 可以看到四个边的border(20)、padding(20)、margin(30)的大小,也可以单独设置某一边的距离，比如设置padding-left: 30px 下面给盒子设置宽度和高度,再查看一下计算结果,如果不设置width和height，默认根据文字大小自动设定 12345678.box-one &#123; background-color: #EB5757; border: 20px solid #9B51E0; padding: 20px; margin: 30px; width: 100px; height: 100px;&#125; 设置了宽度之后，可以看到盒子大小改变成100x100, 这个宽和高设置的实际上是指Content(内容)的大小, 有另一个属性可以改变，那就是box-sizing: content-box|border-box 123456789.box-one &#123; background-color: #EB5757; border: 20px solid #9B51E0; padding: 20px; margin: 30px; width: 100px; height: 100px; box-sizing: border-box;&#125; 可见，如果设置box-sizing: border-box; width设定为100,那么 border+padding+content=100, 此时文字太大，就会超出Content范围 结论 border一般用于分隔不同的元素，border的外围即为元素的最外围，所以计算元素的宽和高时，需要将border计算进来，当然也需要看box-sizing的设置是content-box还是border-box border写法 简写 border: 10px solid #FF9090; 10px是指边框宽, solid是指边框style, #FF9090是指边框颜色 单独写 border-width: 10px; border-style: none|hidden|dotted|dashed|solid|double…; border-color: #FF9090;","categories":[{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/categories/H5/"}],"tags":[{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/tags/H5/"}]},{"title":"玩游戏学前端-贪吃蛇-animationframe","slug":"JavaScript/animationframe","date":"2022-07-17T01:19:55.772Z","updated":"2022-07-17T03:31:07.206Z","comments":true,"path":"2022/07/17/JavaScript/animationframe/","link":"","permalink":"https://zhsunbeam.github.io/2022/07/17/JavaScript/animationframe/","excerpt":"","text":"window.requestAnimationFrame() 方法 现如今，各种web开发技术被引入来创建漂亮的web页面。当谈到漂亮的网页时，最重要的内容之一就是动画。有很多方法可以生成动画，CSS3是其中之一，但JavaScript一直是一个强大的选项。window.requestAnimationFrame()方法是JavaScript中将简单的动画整合到我们的项目中的方法之一。也可以使用早期的方法，如setTimeout()或setInterval()，这两个方法仍然可用，但是使用起来慢且不太优雅，最主要的问题还是同步，过渡时间慢，而且对游戏项目来说体验较差。 语法 window.requestAnimationFrame( callback 回调函数 ); 参数：此方法接收单个参数 callback, 它是一个回调函数; 除非你想要动画停止，否则你应该编写回调函数，便于发出对下一帧的请求。回调函数接受时间戳或一个时间值，在该时间值处开始执行。 返回值：此方法返回一个非零长整型数值，作为回调函数中动画的唯一标识。 示例1: 元素向右移动 12345678910111213141516171819202122232425262728&lt;div id=&quot;panel&quot;&gt; &lt;h1 style=&quot;color: #d662f3;&quot;&gt;我爱你中国&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; //动画起始时间 var start = null; //获取DIV元素对象 var element = document.getElementById(&#x27;panel&#x27;); //开始动画函数，传入时间戳 function startAnimation(timestamp) &#123; // timestamp表示1970年1月1日开始经过的秒数 // 第一次回调此函数 start 为 null, 进入if块之后重新赋值 if (!start) &#123; start = timestamp; &#125; //时间戳-开始时间 表示流逝的时间 var progress = timestamp - start; // 移动元素，使用transform样式 ,变换 x 坐标 element.style.transform = &#x27;translateX(&#x27; + Math.min(progress / 10, 700) + &#x27;px)&#x27;; //再次请求动画帧 window.requestAnimationFrame(startAnimation); &#125; window.requestAnimationFrame(startAnimation);&lt;/script&gt; 回调函数会收到一个参数，这个参数表示当前时间距离开始触发 requestAnimationFrame 的回调的时间。 示例2: 按下按钮元素向右移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; position: absolute; left: 10px; top: 50px; padding: auto; color: white &#125; h1 &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;button onclick=&quot;start()&quot;&gt;开始动画&lt;/button&gt; &lt;/center&gt; &lt;div id=&quot;panel&quot;&gt;&lt;h1&gt;我爱你中国&lt;/h1&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var x = document.getElementById(&quot;panel&quot;); // 初始化变量 var requestId; var stopped; var starttime; function startAnimation(time) &#123; //如果stopped为空 则设置x元素的样式left if (!stopped) &#123; x.style.left = ((Date.now() - starttime) / 10 % 700) + &quot;px&quot;; //返回id requestId = window.requestAnimationFrame(startAnimation); &#125; &#125; function start() &#123; //当前时间 starttime = Date.now(); //开始动画 requestId = window.requestAnimationFrame(startAnimation); // 设置为false表示动画不会停止 stopped = false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"}]},{"title":"一个外包项目","slug":"project/一个外包项目","date":"2021-08-22T04:33:52.000Z","updated":"2021-08-22T13:20:12.574Z","comments":true,"path":"2021/08/22/project/一个外包项目/","link":"","permalink":"https://zhsunbeam.github.io/2021/08/22/project/%E4%B8%80%E4%B8%AA%E5%A4%96%E5%8C%85%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"一个外包小项目，利用业余时间赚点零花钱，甲方要求也简单，这种类型的项目其实到处都是，也可以直接做个搬运工， 但需要改成客户想要的样子，花的时间可能更多，而且需要做成多端应用：微信端和PC端，看看分析后的需求内容吧 员工 员工ID、姓名、个人照片、性别(选择，男|女)、籍贯(选择，省|市|区县)、出生年月日(选择)、学历(选择)、手机、住址、邮箱、毕业院校(手动填写)、专业(手动填写)、工作经历、入职时间(年月日)、岗位名称、操作时间、操作人、状态(在职|离职)。 参与角色：员工或者人事专员 员工证件 员工ID、证件名称ID、证件图、状态。需要员工自己上传的为3个证件：学位证、毕业证、其它技能证书、银行卡、入职体检报告，人事专员需要上传一个合同。 参与角色：员工或者人事专员 员工晋级转岗 员工ID、事项类型(试用期|转岗|晋级)、岗位、时间、操作时间、操作人、备注。 参与角色：人事专员 员工离职 员工ID、离职时间、离职原因、操作人、操作时间、是否已打印离职证明、工作交接是否已完成、是否已归还设备及其他。 参与角色：人事专员 员工资产归属 员工ID、资产编号、领用时间、领用操作人、归还时间、归还操作人、备注。 参与角色：资产管理或者人事专员 如果要根据以上需求来建表，怎么玩?","categories":[{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/categories/JavaScript/"},{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/categories/Java/"},{"name":"前端开发","slug":"前端开发","permalink":"https://zhsunbeam.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JOOQ","slug":"JOOQ","permalink":"https://zhsunbeam.github.io/categories/JOOQ/"},{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/categories/H5/"},{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhsunbeam.github.io/tags/JavaScript/"},{"name":"HTML5/CSS3","slug":"HTML5-CSS3","permalink":"https://zhsunbeam.github.io/tags/HTML5-CSS3/"},{"name":"Java","slug":"Java","permalink":"https://zhsunbeam.github.io/tags/Java/"},{"name":"编程基础","slug":"编程基础","permalink":"https://zhsunbeam.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"HTML","slug":"HTML","permalink":"https://zhsunbeam.github.io/tags/HTML/"},{"name":"ORM框架","slug":"ORM框架","permalink":"https://zhsunbeam.github.io/tags/ORM%E6%A1%86%E6%9E%B6/"},{"name":"H5","slug":"H5","permalink":"https://zhsunbeam.github.io/tags/H5/"},{"name":"项目开发","slug":"项目开发","permalink":"https://zhsunbeam.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}]}